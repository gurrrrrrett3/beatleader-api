/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * BeatLeader-Server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccountLink
 */
export interface AccountLink {
    /**
     * 
     * @type {number}
     * @memberof AccountLink
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountLink
     */
    steamID?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountLink
     */
    oculusID?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountLink
     */
    pcOculusID?: string;
}
/**
 * 
 * @export
 * @interface AccuracyTracker
 */
export interface AccuracyTracker {
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    accRight?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    accLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    leftPreswing?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    rightPreswing?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    averagePreswing?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    leftPostswing?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    rightPostswing?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    leftTimeDependence?: number;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    rightTimeDependence?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AccuracyTracker
     */
    leftAverageCut?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AccuracyTracker
     */
    rightAverageCut?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AccuracyTracker
     */
    gridAcc?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof AccuracyTracker
     */
    fcAcc?: number;
}
/**
 * 
 * @export
 * @interface Achievement
 */
export interface Achievement {
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    playerId?: string;
    /**
     * 
     * @type {Player}
     * @memberof Achievement
     */
    player?: Player;
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    achievementDescriptionId?: number;
    /**
     * 
     * @type {AchievementDescription}
     * @memberof Achievement
     */
    achievementDescription?: AchievementDescription;
    /**
     * 
     * @type {AchievementLevel}
     * @memberof Achievement
     */
    level?: AchievementLevel;
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    timeset?: number;
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface AchievementDescription
 */
export interface AchievementDescription {
    /**
     * 
     * @type {number}
     * @memberof AchievementDescription
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AchievementDescription
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementDescription
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementDescription
     */
    link?: string;
    /**
     * 
     * @type {Array<Achievement>}
     * @memberof AchievementDescription
     */
    achievements?: Array<Achievement>;
    /**
     * 
     * @type {Array<AchievementLevel>}
     * @memberof AchievementDescription
     */
    levels?: Array<AchievementLevel>;
}
/**
 * 
 * @export
 * @interface AchievementLevel
 */
export interface AchievementLevel {
    /**
     * 
     * @type {number}
     * @memberof AchievementLevel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AchievementLevel
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementLevel
     */
    smallImage?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementLevel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementLevel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementLevel
     */
    detailedDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof AchievementLevel
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof AchievementLevel
     */
    value?: number;
    /**
     * 
     * @type {number}
     * @memberof AchievementLevel
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof AchievementLevel
     */
    achievementDescriptionId?: number;
}
/**
 * 
 * @export
 * @interface AveragePosition
 */
export interface AveragePosition {
    /**
     * 
     * @type {number}
     * @memberof AveragePosition
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof AveragePosition
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof AveragePosition
     */
    z?: number;
}
/**
 * 
 * @export
 * @interface Badge
 */
export interface Badge {
    /**
     * 
     * @type {number}
     * @memberof Badge
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    link?: string;
}
/**
 * 
 * @export
 * @interface Ban
 */
export interface Ban {
    /**
     * 
     * @type {number}
     * @memberof Ban
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Ban
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof Ban
     */
    bannedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ban
     */
    banReason?: string;
    /**
     * 
     * @type {number}
     * @memberof Ban
     */
    timeset?: number;
    /**
     * 
     * @type {number}
     * @memberof Ban
     */
    duration?: number;
}
/**
 * 
 * @export
 * @interface BanReturn
 */
export interface BanReturn {
    /**
     * 
     * @type {string}
     * @memberof BanReturn
     */
    reason?: string;
    /**
     * 
     * @type {number}
     * @memberof BanReturn
     */
    timeset?: number;
    /**
     * 
     * @type {number}
     * @memberof BanReturn
     */
    duration?: number;
}
/**
 * 
 * @export
 * @interface Clan
 */
export interface Clan {
    /**
     * 
     * @type {number}
     * @memberof Clan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    leaderID?: string;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Clan
     */
    bio?: string;
    /**
     * 
     * @type {number}
     * @memberof Clan
     */
    playersCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Clan
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof Clan
     */
    averageRank?: number;
    /**
     * 
     * @type {number}
     * @memberof Clan
     */
    averageAccuracy?: number;
    /**
     * 
     * @type {Array<Player>}
     * @memberof Clan
     */
    players?: Array<Player>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Clan
     */
    requests?: Array<User>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Clan
     */
    banned?: Array<User>;
}
/**
 * 
 * @export
 * @interface ClanResponse
 */
export interface ClanResponse {
    /**
     * 
     * @type {number}
     * @memberof ClanResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClanResponse
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof ClanResponse
     */
    color?: string;
}
/**
 * 
 * @export
 * @interface ClanResponseWithMetadata
 */
export interface ClanResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof ClanResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<Clan>}
     * @memberof ClanResponseWithMetadata
     */
    data?: Array<Clan>;
}
/**
 * 
 * @export
 * @interface ClanReturn
 */
export interface ClanReturn {
    /**
     * 
     * @type {number}
     * @memberof ClanReturn
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClanReturn
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClanReturn
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof ClanReturn
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof ClanReturn
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof ClanReturn
     */
    leaderID?: string;
    /**
     * 
     * @type {number}
     * @memberof ClanReturn
     */
    playersCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ClanReturn
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof ClanReturn
     */
    averageRank?: number;
    /**
     * 
     * @type {number}
     * @memberof ClanReturn
     */
    averageAccuracy?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClanReturn
     */
    players?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClanReturn
     */
    pendingInvites?: Array<string>;
}
/**
 * 
 * @export
 * @interface CompactLeaderboard
 */
export interface CompactLeaderboard {
    /**
     * 
     * @type {string}
     * @memberof CompactLeaderboard
     */
    songHash?: string;
    /**
     * 
     * @type {number}
     * @memberof CompactLeaderboard
     */
    difficulty?: number;
}
/**
 * 
 * @export
 * @interface CompactScore
 */
export interface CompactScore {
    /**
     * 
     * @type {number}
     * @memberof CompactScore
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof CompactScore
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof CompactScore
     */
    maxCombo?: number;
    /**
     * 
     * @type {number}
     * @memberof CompactScore
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof CompactScore
     */
    badCuts?: number;
    /**
     * 
     * @type {HMD}
     * @memberof CompactScore
     */
    hmd?: HMD;
    /**
     * 
     * @type {number}
     * @memberof CompactScore
     */
    epochTime?: number;
}
/**
 * 
 * @export
 * @interface CompactScoreResponse
 */
export interface CompactScoreResponse {
    /**
     * 
     * @type {CompactScore}
     * @memberof CompactScoreResponse
     */
    score?: CompactScore;
    /**
     * 
     * @type {CompactLeaderboard}
     * @memberof CompactScoreResponse
     */
    leaderboard?: CompactLeaderboard;
}
/**
 * 
 * @export
 * @interface CompactScoreResponseResponseWithMetadata
 */
export interface CompactScoreResponseResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof CompactScoreResponseResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<CompactScoreResponse>}
     * @memberof CompactScoreResponseResponseWithMetadata
     */
    data?: Array<CompactScoreResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ControllerEnum {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_4 = <any> 4,
    NUMBER_8 = <any> 8,
    NUMBER_9 = <any> 9,
    NUMBER_10 = <any> 10,
    NUMBER_16 = <any> 16,
    NUMBER_33 = <any> 33,
    NUMBER_34 = <any> 34,
    NUMBER_35 = <any> 35,
    NUMBER_37 = <any> 37,
    NUMBER_44 = <any> 44,
    NUMBER_61 = <any> 61,
    NUMBER_62 = <any> 62,
    NUMBER_63 = <any> 63,
    NUMBER_64 = <any> 64,
    NUMBER_65 = <any> 65,
    NUMBER_66 = <any> 66,
    NUMBER_67 = <any> 67,
    NUMBER_68 = <any> 68,
    NUMBER_69 = <any> 69,
    NUMBER_70 = <any> 70,
    NUMBER_71 = <any> 71,
    NUMBER_72 = <any> 72,
    NUMBER_73 = <any> 73,
    NUMBER_74 = <any> 74,
    NUMBER_75 = <any> 75,
    NUMBER_76 = <any> 76,
    NUMBER_77 = <any> 77,
    NUMBER_128 = <any> 128,
    NUMBER_256 = <any> 256
}
/**
 * 
 * @export
 * @interface CriteriaCommentary
 */
export interface CriteriaCommentary {
    /**
     * 
     * @type {number}
     * @memberof CriteriaCommentary
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CriteriaCommentary
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof CriteriaCommentary
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof CriteriaCommentary
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CriteriaCommentary
     */
    editTimeset?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CriteriaCommentary
     */
    edited?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CriteriaCommentary
     */
    rankQualificationId?: number;
    /**
     * 
     * @type {RankQualification}
     * @memberof CriteriaCommentary
     */
    rankQualification?: RankQualification;
    /**
     * 
     * @type {string}
     * @memberof CriteriaCommentary
     */
    discordMessageId?: string;
}
/**
 * 
 * @export
 * @interface DiffCheckResult
 */
export interface DiffCheckResult {
    /**
     * 
     * @type {DiffCriteriaReport}
     * @memberof DiffCheckResult
     */
    criteriaReport?: DiffCriteriaReport;
    /**
     * 
     * @type {string}
     * @memberof DiffCheckResult
     */
    diff?: string;
    /**
     * 
     * @type {string}
     * @memberof DiffCheckResult
     */
    characteristic?: string;
}
/**
 * 
 * @export
 * @interface DiffCriteriaReport
 */
export interface DiffCriteriaReport {
    /**
     * 
     * @type {Array<string>}
     * @memberof DiffCriteriaReport
     */
    modsRequired?: Array<string>;
    /**
     * 
     * @type {Array<MapNote>}
     * @memberof DiffCriteriaReport
     */
    noteHotStarts?: Array<MapNote>;
    /**
     * 
     * @type {Array<MapObstacle>}
     * @memberof DiffCriteriaReport
     */
    wallHotStarts?: Array<MapObstacle>;
    /**
     * 
     * @type {Array<MapNote>}
     * @memberof DiffCriteriaReport
     */
    noteColdEnds?: Array<MapNote>;
    /**
     * 
     * @type {Array<MapObstacle>}
     * @memberof DiffCriteriaReport
     */
    wallColdEnds?: Array<MapObstacle>;
    /**
     * 
     * @type {Array<MapNote>}
     * @memberof DiffCriteriaReport
     */
    noteIntersections?: Array<MapNote>;
    /**
     * 
     * @type {Array<MapObstacle>}
     * @memberof DiffCriteriaReport
     */
    wallIntersections?: Array<MapObstacle>;
    /**
     * 
     * @type {Array<MapNote>}
     * @memberof DiffCriteriaReport
     */
    noteOutOfRange?: Array<MapNote>;
    /**
     * 
     * @type {Array<MapObstacle>}
     * @memberof DiffCriteriaReport
     */
    wallOutOfRange?: Array<MapObstacle>;
    /**
     * 
     * @type {Array<MapNote>}
     * @memberof DiffCriteriaReport
     */
    noteFailSwings?: Array<MapNote>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DiffCriteriaReport
     */
    errors?: Array<number>;
}
/**
 * 
 * @export
 * @interface DiffModResponse
 */
export interface DiffModResponse {
    /**
     * 
     * @type {string}
     * @memberof DiffModResponse
     */
    difficultyName?: string;
    /**
     * 
     * @type {string}
     * @memberof DiffModResponse
     */
    modeName?: string;
    /**
     * 
     * @type {number}
     * @memberof DiffModResponse
     */
    stars?: number;
    /**
     * 
     * @type {DifficultyStatus}
     * @memberof DiffModResponse
     */
    status?: DifficultyStatus;
    /**
     * 
     * @type {number}
     * @memberof DiffModResponse
     */
    type?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DiffModResponse
     */
    votes?: Array<number>;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof DiffModResponse
     */
    modifierValues?: ModifiersMap;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof DiffModResponse
     */
    modifiersRating?: ModifiersRating;
    /**
     * 
     * @type {number}
     * @memberof DiffModResponse
     */
    passRating?: number;
    /**
     * 
     * @type {number}
     * @memberof DiffModResponse
     */
    accRating?: number;
    /**
     * 
     * @type {number}
     * @memberof DiffModResponse
     */
    techRating?: number;
}
/**
 * 
 * @export
 * @interface DifficultyDescription
 */
export interface DifficultyDescription {
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    value?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    mode?: number;
    /**
     * 
     * @type {string}
     * @memberof DifficultyDescription
     */
    difficultyName?: string;
    /**
     * 
     * @type {string}
     * @memberof DifficultyDescription
     */
    modeName?: string;
    /**
     * 
     * @type {DifficultyStatus}
     * @memberof DifficultyDescription
     */
    status?: DifficultyStatus;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof DifficultyDescription
     */
    modifierValues?: ModifiersMap;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof DifficultyDescription
     */
    modifiersRating?: ModifiersRating;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    nominatedTime?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    qualifiedTime?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    rankedTime?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    stars?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    predictedAcc?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    passRating?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    accRating?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    techRating?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    njs?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    nps?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    notes?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    bombs?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    walls?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    maxScore?: number;
    /**
     * 
     * @type {number}
     * @memberof DifficultyDescription
     */
    duration?: number;
    /**
     * 
     * @type {Requirements}
     * @memberof DifficultyDescription
     */
    requirements?: Requirements;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DifficultyStatus {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4,
    NUMBER_5 = <any> 5,
    NUMBER_6 = <any> 6
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EndType {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4
}
/**
 * 
 * @export
 * @interface EventPlayer
 */
export interface EventPlayer {
    /**
     * 
     * @type {number}
     * @memberof EventPlayer
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof EventPlayer
     */
    eventId?: number;
    /**
     * 
     * @type {string}
     * @memberof EventPlayer
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EventPlayer
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventPlayer
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof EventPlayer
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof EventPlayer
     */
    countryRank?: number;
    /**
     * 
     * @type {number}
     * @memberof EventPlayer
     */
    pp?: number;
}
/**
 * 
 * @export
 * @interface EventRanking
 */
export interface EventRanking {
    /**
     * 
     * @type {number}
     * @memberof EventRanking
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EventRanking
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof EventRanking
     */
    endDate?: number;
    /**
     * 
     * @type {number}
     * @memberof EventRanking
     */
    playlistId?: number;
    /**
     * 
     * @type {string}
     * @memberof EventRanking
     */
    image?: string;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof EventRanking
     */
    leaderboards?: Array<Leaderboard>;
    /**
     * 
     * @type {Array<EventPlayer>}
     * @memberof EventRanking
     */
    players?: Array<EventPlayer>;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * 
     * @type {number}
     * @memberof EventResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof EventResponse
     */
    endDate?: number;
    /**
     * 
     * @type {number}
     * @memberof EventResponse
     */
    playlistId?: number;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    image?: string;
    /**
     * 
     * @type {number}
     * @memberof EventResponse
     */
    playerCount?: number;
    /**
     * 
     * @type {PlayerResponse}
     * @memberof EventResponse
     */
    leader?: PlayerResponse;
}
/**
 * 
 * @export
 * @interface EventResponseResponseWithMetadata
 */
export interface EventResponseResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof EventResponseResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<EventResponse>}
     * @memberof EventResponseResponseWithMetadata
     */
    data?: Array<EventResponse>;
}
/**
 * 
 * @export
 * @interface FailedScore
 */
export interface FailedScore {
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof FailedScore
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    countryRank?: number;
    /**
     * 
     * @type {string}
     * @memberof FailedScore
     */
    replay?: string;
    /**
     * 
     * @type {string}
     * @memberof FailedScore
     */
    modifiers?: string;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    badCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    bombCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    wallsHit?: number;
    /**
     * 
     * @type {number}
     * @memberof FailedScore
     */
    pauses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FailedScore
     */
    fullCombo?: boolean;
    /**
     * 
     * @type {HMD}
     * @memberof FailedScore
     */
    hmd?: HMD;
    /**
     * 
     * @type {string}
     * @memberof FailedScore
     */
    timeset?: string;
    /**
     * 
     * @type {Player}
     * @memberof FailedScore
     */
    player?: Player;
    /**
     * 
     * @type {Leaderboard}
     * @memberof FailedScore
     */
    leaderboard?: Leaderboard;
    /**
     * 
     * @type {string}
     * @memberof FailedScore
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FailedScore
     */
    falsePositive?: boolean;
}
/**
 * 
 * @export
 * @interface FailedScoreResponseWithMetadata
 */
export interface FailedScoreResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof FailedScoreResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<FailedScore>}
     * @memberof FailedScoreResponseWithMetadata
     */
    data?: Array<FailedScore>;
}
/**
 * 
 * @export
 * @interface FriendActivity
 */
export interface FriendActivity {
    /**
     * 
     * @type {PlayerResponse}
     * @memberof FriendActivity
     */
    player?: PlayerResponse;
    /**
     * 
     * @type {FriendActivityType}
     * @memberof FriendActivity
     */
    type?: FriendActivityType;
    /**
     * 
     * @type {any}
     * @memberof FriendActivity
     */
    activityObject?: any;
}
/**
 * 
 * @export
 * @interface FriendActivityResponseWithMetadata
 */
export interface FriendActivityResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof FriendActivityResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<FriendActivity>}
     * @memberof FriendActivityResponseWithMetadata
     */
    data?: Array<FriendActivity>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FriendActivityType {
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4
}
/**
 * 
 * @export
 * @interface GraphResponse
 */
export interface GraphResponse {
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    leaderboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    diff?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    modifiers?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    songName?: string;
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    mapper?: string;
    /**
     * 
     * @type {number}
     * @memberof GraphResponse
     */
    acc?: number;
    /**
     * 
     * @type {string}
     * @memberof GraphResponse
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof GraphResponse
     */
    stars?: number;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof GraphResponse
     */
    modifiersRating?: ModifiersRating;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof GraphResponse
     */
    modifierValues?: ModifiersMap;
    /**
     * 
     * @type {number}
     * @memberof GraphResponse
     */
    passRating?: number;
    /**
     * 
     * @type {number}
     * @memberof GraphResponse
     */
    accRating?: number;
    /**
     * 
     * @type {number}
     * @memberof GraphResponse
     */
    techRating?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HMD {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_4 = <any> 4,
    NUMBER_8 = <any> 8,
    NUMBER_16 = <any> 16,
    NUMBER_32 = <any> 32,
    NUMBER_33 = <any> 33,
    NUMBER_34 = <any> 34,
    NUMBER_35 = <any> 35,
    NUMBER_36 = <any> 36,
    NUMBER_37 = <any> 37,
    NUMBER_38 = <any> 38,
    NUMBER_39 = <any> 39,
    NUMBER_40 = <any> 40,
    NUMBER_41 = <any> 41,
    NUMBER_42 = <any> 42,
    NUMBER_43 = <any> 43,
    NUMBER_44 = <any> 44,
    NUMBER_45 = <any> 45,
    NUMBER_46 = <any> 46,
    NUMBER_47 = <any> 47,
    NUMBER_48 = <any> 48,
    NUMBER_49 = <any> 49,
    NUMBER_50 = <any> 50,
    NUMBER_51 = <any> 51,
    NUMBER_52 = <any> 52,
    NUMBER_53 = <any> 53,
    NUMBER_54 = <any> 54,
    NUMBER_55 = <any> 55,
    NUMBER_56 = <any> 56,
    NUMBER_57 = <any> 57,
    NUMBER_58 = <any> 58,
    NUMBER_59 = <any> 59,
    NUMBER_60 = <any> 60,
    NUMBER_61 = <any> 61,
    NUMBER_62 = <any> 62,
    NUMBER_63 = <any> 63,
    NUMBER_64 = <any> 64,
    NUMBER_65 = <any> 65,
    NUMBER_128 = <any> 128,
    NUMBER_256 = <any> 256
}
/**
 * 
 * @export
 * @interface HitTracker
 */
export interface HitTracker {
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    maxCombo?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    maxStreak?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    leftTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    rightTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    leftMiss?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    rightMiss?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    leftBadCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    rightBadCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    leftBombs?: number;
    /**
     * 
     * @type {number}
     * @memberof HitTracker
     */
    rightBombs?: number;
}
/**
 * 
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    songId?: string;
    /**
     * 
     * @type {Song}
     * @memberof Leaderboard
     */
    song?: Song;
    /**
     * 
     * @type {DifficultyDescription}
     * @memberof Leaderboard
     */
    difficulty?: DifficultyDescription;
    /**
     * 
     * @type {Array<Score>}
     * @memberof Leaderboard
     */
    scores?: Array<Score>;
    /**
     * 
     * @type {RankQualification}
     * @memberof Leaderboard
     */
    qualification?: RankQualification;
    /**
     * 
     * @type {RankUpdate}
     * @memberof Leaderboard
     */
    reweight?: RankUpdate;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    timestamp?: number;
    /**
     * 
     * @type {LeaderboardGroup}
     * @memberof Leaderboard
     */
    leaderboardGroup?: LeaderboardGroup;
    /**
     * 
     * @type {Array<LeaderboardChange>}
     * @memberof Leaderboard
     */
    changes?: Array<LeaderboardChange>;
    /**
     * 
     * @type {Array<PlayerLeaderboardStats>}
     * @memberof Leaderboard
     */
    playerStats?: Array<PlayerLeaderboardStats>;
    /**
     * 
     * @type {Array<EventRanking>}
     * @memberof Leaderboard
     */
    events?: Array<EventRanking>;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    plays?: number;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    playCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    positiveVotes?: number;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    starVotes?: number;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    negativeVotes?: number;
    /**
     * 
     * @type {number}
     * @memberof Leaderboard
     */
    voteStars?: number;
}
/**
 * 
 * @export
 * @interface LeaderboardChange
 */
export interface LeaderboardChange {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardChange
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldRankability?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldStars?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldType?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    oldCriteriaMet?: number;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof LeaderboardChange
     */
    oldModifiers?: ModifiersMap;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof LeaderboardChange
     */
    oldModifiersRating?: ModifiersRating;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newRankability?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newStars?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newType?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardChange
     */
    newCriteriaMet?: number;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof LeaderboardChange
     */
    newModifiers?: ModifiersMap;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof LeaderboardChange
     */
    newModifiersRating?: ModifiersRating;
}
/**
 * 
 * @export
 * @interface LeaderboardGroup
 */
export interface LeaderboardGroup {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardGroup
     */
    id?: number;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof LeaderboardGroup
     */
    leaderboards?: Array<Leaderboard>;
}
/**
 * 
 * @export
 * @interface LeaderboardGroupEntry
 */
export interface LeaderboardGroupEntry {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardGroupEntry
     */
    id?: string;
    /**
     * 
     * @type {DifficultyStatus}
     * @memberof LeaderboardGroupEntry
     */
    status?: DifficultyStatus;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardGroupEntry
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @interface LeaderboardInfoResponse
 */
export interface LeaderboardInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardInfoResponse
     */
    id?: string;
    /**
     * 
     * @type {Song}
     * @memberof LeaderboardInfoResponse
     */
    song?: Song;
    /**
     * 
     * @type {DifficultyDescription}
     * @memberof LeaderboardInfoResponse
     */
    difficulty?: DifficultyDescription;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardInfoResponse
     */
    plays?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardInfoResponse
     */
    positiveVotes?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardInfoResponse
     */
    starVotes?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardInfoResponse
     */
    negativeVotes?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardInfoResponse
     */
    voteStars?: number;
    /**
     * 
     * @type {ScoreResponseWithAcc}
     * @memberof LeaderboardInfoResponse
     */
    myScore?: ScoreResponseWithAcc;
    /**
     * 
     * @type {RankQualification}
     * @memberof LeaderboardInfoResponse
     */
    qualification?: RankQualification;
    /**
     * 
     * @type {RankUpdate}
     * @memberof LeaderboardInfoResponse
     */
    reweight?: RankUpdate;
}
/**
 * 
 * @export
 * @interface LeaderboardInfoResponseResponseWithMetadata
 */
export interface LeaderboardInfoResponseResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof LeaderboardInfoResponseResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<LeaderboardInfoResponse>}
     * @memberof LeaderboardInfoResponseResponseWithMetadata
     */
    data?: Array<LeaderboardInfoResponse>;
}
/**
 * 
 * @export
 * @interface LeaderboardResponse
 */
export interface LeaderboardResponse {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardResponse
     */
    id?: string;
    /**
     * 
     * @type {Song}
     * @memberof LeaderboardResponse
     */
    song?: Song;
    /**
     * 
     * @type {DifficultyDescription}
     * @memberof LeaderboardResponse
     */
    difficulty?: DifficultyDescription;
    /**
     * 
     * @type {Array<ScoreResponse>}
     * @memberof LeaderboardResponse
     */
    scores?: Array<ScoreResponse>;
    /**
     * 
     * @type {Array<LeaderboardChange>}
     * @memberof LeaderboardResponse
     */
    changes?: Array<LeaderboardChange>;
    /**
     * 
     * @type {RankQualification}
     * @memberof LeaderboardResponse
     */
    qualification?: RankQualification;
    /**
     * 
     * @type {RankUpdate}
     * @memberof LeaderboardResponse
     */
    reweight?: RankUpdate;
    /**
     * 
     * @type {Array<LeaderboardGroupEntry>}
     * @memberof LeaderboardResponse
     */
    leaderboardGroup?: Array<LeaderboardGroupEntry>;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardResponse
     */
    plays?: number;
}
/**
 * 
 * @export
 * @interface LeaderboardVoting
 */
export interface LeaderboardVoting {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardVoting
     */
    rankability?: number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardVoting
     */
    stars?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof LeaderboardVoting
     */
    type?: Array<number>;
}
/**
 * 
 * @export
 * @interface LeaderboardsInfoResponse
 */
export interface LeaderboardsInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardsInfoResponse
     */
    id?: string;
    /**
     * 
     * @type {DifficultyDescription}
     * @memberof LeaderboardsInfoResponse
     */
    difficulty?: DifficultyDescription;
    /**
     * 
     * @type {RankQualification}
     * @memberof LeaderboardsInfoResponse
     */
    qualification?: RankQualification;
    /**
     * 
     * @type {RankUpdate}
     * @memberof LeaderboardsInfoResponse
     */
    reweight?: RankUpdate;
}
/**
 * 
 * @export
 * @interface LeaderboardsResponse
 */
export interface LeaderboardsResponse {
    /**
     * 
     * @type {Song}
     * @memberof LeaderboardsResponse
     */
    song?: Song;
    /**
     * 
     * @type {Array<LeaderboardsInfoResponse>}
     * @memberof LeaderboardsResponse
     */
    leaderboards?: Array<LeaderboardsInfoResponse>;
}
/**
 * 
 * @export
 * @interface MapCheckResult
 */
export interface MapCheckResult {
    /**
     * 
     * @type {Array<DiffCheckResult>}
     * @memberof MapCheckResult
     */
    diffs?: Array<DiffCheckResult>;
    /**
     * 
     * @type {Array<ProfanityCheckResult>}
     * @memberof MapCheckResult
     */
    profanityCheck?: Array<ProfanityCheckResult>;
}
/**
 * 
 * @export
 * @interface MapNote
 */
export interface MapNote {
    /**
     * 
     * @type {number}
     * @memberof MapNote
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof MapNote
     */
    lineIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof MapNote
     */
    lineLayer?: number;
    /**
     * 
     * @type {NoteType}
     * @memberof MapNote
     */
    type?: NoteType;
    /**
     * 
     * @type {NoteCutDirection}
     * @memberof MapNote
     */
    cutDirection?: NoteCutDirection;
    /**
     * 
     * @type {number}
     * @memberof MapNote
     */
    realTime?: number;
}
/**
 * 
 * @export
 * @interface MapObstacle
 */
export interface MapObstacle {
    /**
     * 
     * @type {number}
     * @memberof MapObstacle
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof MapObstacle
     */
    lineIndex?: number;
    /**
     * 
     * @type {ObstacleType}
     * @memberof MapObstacle
     */
    type?: ObstacleType;
    /**
     * 
     * @type {number}
     * @memberof MapObstacle
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof MapObstacle
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof MapObstacle
     */
    realTime?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MapQuality {
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    itemsPerPage?: number;
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface MiniRankingPlayer
 */
export interface MiniRankingPlayer {
    /**
     * 
     * @type {string}
     * @memberof MiniRankingPlayer
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MiniRankingPlayer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MiniRankingPlayer
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof MiniRankingPlayer
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof MiniRankingPlayer
     */
    countryRank?: number;
    /**
     * 
     * @type {number}
     * @memberof MiniRankingPlayer
     */
    pp?: number;
}
/**
 * 
 * @export
 * @interface MiniRankingResponse
 */
export interface MiniRankingResponse {
    /**
     * 
     * @type {Array<MiniRankingPlayer>}
     * @memberof MiniRankingResponse
     */
    global?: Array<MiniRankingPlayer>;
    /**
     * 
     * @type {Array<MiniRankingPlayer>}
     * @memberof MiniRankingResponse
     */
    country?: Array<MiniRankingPlayer>;
}
/**
 * 
 * @export
 * @interface ModifiersMap
 */
export interface ModifiersMap {
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    modifierId?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    da?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    fs?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    sf?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    ss?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    gn?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    na?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    nb?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    nf?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    no?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    pm?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    sc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    sa?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersMap
     */
    op?: number;
}
/**
 * 
 * @export
 * @interface ModifiersRating
 */
export interface ModifiersRating {
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    fsPredictedAcc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    fsPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    fsAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    fsTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    fsStars?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    ssPredictedAcc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    ssPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    ssAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    ssTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    ssStars?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    sfPredictedAcc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    sfPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    sfAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    sfTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifiersRating
     */
    sfStars?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MyType {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4,
    NUMBER_5 = <any> 5
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NoteCutDirection {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4,
    NUMBER_5 = <any> 5,
    NUMBER_6 = <any> 6,
    NUMBER_7 = <any> 7,
    NUMBER_8 = <any> 8
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NoteType {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_3 = <any> 3
}
/**
 * 
 * @export
 * @interface OauthClientInfo
 */
export interface OauthClientInfo {
    /**
     * 
     * @type {string}
     * @memberof OauthClientInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientInfo
     */
    icon?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ObstacleType {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1
}
/**
 * 
 * @export
 * @interface OculusUser
 */
export interface OculusUser {
    /**
     * 
     * @type {string}
     * @memberof OculusUser
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OculusUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OculusUser
     */
    avatar?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OculusUser
     */
    migrated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OculusUser
     */
    migratedId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Operation {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Order {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1
}
/**
 * 
 * @export
 * @interface PatreonFeatures
 */
export interface PatreonFeatures {
    /**
     * 
     * @type {number}
     * @memberof PatreonFeatures
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatreonFeatures
     */
    bio?: string;
    /**
     * 
     * @type {string}
     * @memberof PatreonFeatures
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof PatreonFeatures
     */
    leftSaberColor?: string;
    /**
     * 
     * @type {string}
     * @memberof PatreonFeatures
     */
    rightSaberColor?: string;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    role?: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    mapperId?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    accPp?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    techPp?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    passPp?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    countryRank?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    lastWeekPp?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    lastWeekRank?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    lastWeekCountryRank?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    banned?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    bot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    inactive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    externalProfileUrl?: string;
    /**
     * 
     * @type {PlayerScoreStats}
     * @memberof Player
     */
    scoreStats?: PlayerScoreStats;
    /**
     * 
     * @type {Array<Clan>}
     * @memberof Player
     */
    clans?: Array<Clan>;
    /**
     * 
     * @type {Array<PlayerFriends>}
     * @memberof Player
     */
    friends?: Array<PlayerFriends>;
    /**
     * 
     * @type {Array<Badge>}
     * @memberof Player
     */
    badges?: Array<Badge>;
    /**
     * 
     * @type {PatreonFeatures}
     * @memberof Player
     */
    patreonFeatures?: PatreonFeatures;
    /**
     * 
     * @type {ProfileSettings}
     * @memberof Player
     */
    profileSettings?: ProfileSettings;
    /**
     * 
     * @type {Array<PlayerChange>}
     * @memberof Player
     */
    changes?: Array<PlayerChange>;
    /**
     * 
     * @type {Array<PlayerScoreStatsHistory>}
     * @memberof Player
     */
    history?: Array<PlayerScoreStatsHistory>;
    /**
     * 
     * @type {Array<EventPlayer>}
     * @memberof Player
     */
    eventsParticipating?: Array<EventPlayer>;
    /**
     * 
     * @type {Array<PlayerSocial>}
     * @memberof Player
     */
    socials?: Array<PlayerSocial>;
    /**
     * 
     * @type {Array<Achievement>}
     * @memberof Player
     */
    achievements?: Array<Achievement>;
}
/**
 * 
 * @export
 * @interface PlayerChange
 */
export interface PlayerChange {
    /**
     * 
     * @type {number}
     * @memberof PlayerChange
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerChange
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerChange
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerChange
     */
    oldName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerChange
     */
    newName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerChange
     */
    oldCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerChange
     */
    newCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerChange
     */
    changer?: string;
}
/**
 * 
 * @export
 * @interface PlayerFriends
 */
export interface PlayerFriends {
    /**
     * 
     * @type {string}
     * @memberof PlayerFriends
     */
    id?: string;
    /**
     * 
     * @type {Array<Player>}
     * @memberof PlayerFriends
     */
    friends?: Array<Player>;
}
/**
 * 
 * @export
 * @interface PlayerLeaderboardStats
 */
export interface PlayerLeaderboardStats {
    /**
     * 
     * @type {number}
     * @memberof PlayerLeaderboardStats
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerLeaderboardStats
     */
    playerId?: string;
    /**
     * 
     * @type {EndType}
     * @memberof PlayerLeaderboardStats
     */
    type?: EndType;
    /**
     * 
     * @type {number}
     * @memberof PlayerLeaderboardStats
     */
    timeset?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerLeaderboardStats
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerLeaderboardStats
     */
    score?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerLeaderboardStats
     */
    replay?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerLeaderboardStats
     */
    leaderboardId?: string;
    /**
     * 
     * @type {Leaderboard}
     * @memberof PlayerLeaderboardStats
     */
    leaderboard?: Leaderboard;
}
/**
 * 
 * @export
 * @interface PlayerLeaderboardStatsResponseWithMetadata
 */
export interface PlayerLeaderboardStatsResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof PlayerLeaderboardStatsResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<PlayerLeaderboardStats>}
     * @memberof PlayerLeaderboardStatsResponseWithMetadata
     */
    data?: Array<PlayerLeaderboardStats>;
}
/**
 * 
 * @export
 * @interface PlayerResponse
 */
export interface PlayerResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    country?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponse
     */
    bot?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponse
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponse
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponse
     */
    countryRank?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    role?: string;
    /**
     * 
     * @type {Array<PlayerSocial>}
     * @memberof PlayerResponse
     */
    socials?: Array<PlayerSocial>;
    /**
     * 
     * @type {PatreonFeatures}
     * @memberof PlayerResponse
     */
    patreonFeatures?: PatreonFeatures;
    /**
     * 
     * @type {ProfileSettings}
     * @memberof PlayerResponse
     */
    profileSettings?: ProfileSettings;
    /**
     * 
     * @type {Array<ClanResponse>}
     * @memberof PlayerResponse
     */
    clans?: Array<ClanResponse>;
}
/**
 * 
 * @export
 * @interface PlayerResponseClanResponseWithMetadataAndContainer
 */
export interface PlayerResponseClanResponseWithMetadataAndContainer {
    /**
     * 
     * @type {Metadata}
     * @memberof PlayerResponseClanResponseWithMetadataAndContainer
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<PlayerResponse>}
     * @memberof PlayerResponseClanResponseWithMetadataAndContainer
     */
    data?: Array<PlayerResponse>;
    /**
     * 
     * @type {Clan}
     * @memberof PlayerResponseClanResponseWithMetadataAndContainer
     */
    container?: Clan;
}
/**
 * 
 * @export
 * @interface PlayerResponseFull
 */
export interface PlayerResponseFull {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    country?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseFull
     */
    bot?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    countryRank?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    role?: string;
    /**
     * 
     * @type {Array<PlayerSocial>}
     * @memberof PlayerResponseFull
     */
    socials?: Array<PlayerSocial>;
    /**
     * 
     * @type {PatreonFeatures}
     * @memberof PlayerResponseFull
     */
    patreonFeatures?: PatreonFeatures;
    /**
     * 
     * @type {ProfileSettings}
     * @memberof PlayerResponseFull
     */
    profileSettings?: ProfileSettings;
    /**
     * 
     * @type {Array<ClanResponse>}
     * @memberof PlayerResponseFull
     */
    clans?: Array<ClanResponse>;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    accPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    passPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    techPp?: number;
    /**
     * 
     * @type {PlayerScoreStats}
     * @memberof PlayerResponseFull
     */
    scoreStats?: PlayerScoreStats;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    lastWeekPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    lastWeekRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    lastWeekCountryRank?: number;
    /**
     * 
     * @type {Array<EventPlayer>}
     * @memberof PlayerResponseFull
     */
    eventsParticipating?: Array<EventPlayer>;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseFull
     */
    mapperId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseFull
     */
    banned?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseFull
     */
    inactive?: boolean;
    /**
     * 
     * @type {Ban}
     * @memberof PlayerResponseFull
     */
    banDescription?: Ban;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseFull
     */
    externalProfileUrl?: string;
    /**
     * 
     * @type {Array<PlayerScoreStatsHistory>}
     * @memberof PlayerResponseFull
     */
    history?: Array<PlayerScoreStatsHistory>;
    /**
     * 
     * @type {Array<Badge>}
     * @memberof PlayerResponseFull
     */
    badges?: Array<Badge>;
    /**
     * 
     * @type {Array<ScoreResponseWithMyScore>}
     * @memberof PlayerResponseFull
     */
    pinnedScores?: Array<ScoreResponseWithMyScore>;
    /**
     * 
     * @type {Array<PlayerChange>}
     * @memberof PlayerResponseFull
     */
    changes?: Array<PlayerChange>;
}
/**
 * 
 * @export
 * @interface PlayerResponseWithFriends
 */
export interface PlayerResponseWithFriends {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithFriends
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithFriends
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithFriends
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithFriends
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithFriends
     */
    country?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseWithFriends
     */
    bot?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithFriends
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithFriends
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithFriends
     */
    countryRank?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithFriends
     */
    role?: string;
    /**
     * 
     * @type {Array<PlayerSocial>}
     * @memberof PlayerResponseWithFriends
     */
    socials?: Array<PlayerSocial>;
    /**
     * 
     * @type {PatreonFeatures}
     * @memberof PlayerResponseWithFriends
     */
    patreonFeatures?: PatreonFeatures;
    /**
     * 
     * @type {ProfileSettings}
     * @memberof PlayerResponseWithFriends
     */
    profileSettings?: ProfileSettings;
    /**
     * 
     * @type {Array<ClanResponse>}
     * @memberof PlayerResponseWithFriends
     */
    clans?: Array<ClanResponse>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerResponseWithFriends
     */
    friends?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlayerResponseWithStats
 */
export interface PlayerResponseWithStats {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithStats
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithStats
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithStats
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithStats
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithStats
     */
    country?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseWithStats
     */
    bot?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    countryRank?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseWithStats
     */
    role?: string;
    /**
     * 
     * @type {Array<PlayerSocial>}
     * @memberof PlayerResponseWithStats
     */
    socials?: Array<PlayerSocial>;
    /**
     * 
     * @type {PatreonFeatures}
     * @memberof PlayerResponseWithStats
     */
    patreonFeatures?: PatreonFeatures;
    /**
     * 
     * @type {ProfileSettings}
     * @memberof PlayerResponseWithStats
     */
    profileSettings?: ProfileSettings;
    /**
     * 
     * @type {Array<ClanResponse>}
     * @memberof PlayerResponseWithStats
     */
    clans?: Array<ClanResponse>;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    accPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    passPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    techPp?: number;
    /**
     * 
     * @type {PlayerScoreStats}
     * @memberof PlayerResponseWithStats
     */
    scoreStats?: PlayerScoreStats;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    lastWeekPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    lastWeekRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseWithStats
     */
    lastWeekCountryRank?: number;
    /**
     * 
     * @type {Array<EventPlayer>}
     * @memberof PlayerResponseWithStats
     */
    eventsParticipating?: Array<EventPlayer>;
}
/**
 * 
 * @export
 * @interface PlayerResponseWithStatsResponseWithMetadata
 */
export interface PlayerResponseWithStatsResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof PlayerResponseWithStatsResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<PlayerResponseWithStats>}
     * @memberof PlayerResponseWithStatsResponseWithMetadata
     */
    data?: Array<PlayerResponseWithStats>;
}
/**
 * 
 * @export
 * @interface PlayerScoreStats
 */
export interface PlayerScoreStats {
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    totalScore?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    totalUnrankedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    totalRankedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    lastScoreTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    lastUnrankedScoreTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    lastRankedScoreTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageWeightedRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageUnrankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    medianRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    medianAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topUnrankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topBonusPP?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topPassPP?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topAccPP?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    topTechPP?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    peakRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    rankedMaxStreak?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    unrankedMaxStreak?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    maxStreak?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageLeftTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageRightTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    rankedPlayCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    unrankedPlayCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    totalPlayCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageRankedRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageWeightedRankedRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageUnrankedRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    averageRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    sspPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    ssPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    spPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    sPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    aPlays?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerScoreStats
     */
    topPlatform?: string;
    /**
     * 
     * @type {HMD}
     * @memberof PlayerScoreStats
     */
    topHMD?: HMD;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    dailyImprovements?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    authorizedReplayWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    anonimusReplayWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStats
     */
    watchedReplays?: number;
}
/**
 * 
 * @export
 * @interface PlayerScoreStatsHistory
 */
export interface PlayerScoreStatsHistory {
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerScoreStatsHistory
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    countryRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    totalScore?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    totalUnrankedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    totalRankedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    lastScoreTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    lastUnrankedScoreTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    lastRankedScoreTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageWeightedRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageUnrankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    medianRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    medianAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    topRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    topUnrankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    topAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    topPp?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    topBonusPP?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    peakRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    maxStreak?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageLeftTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageRightTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    rankedPlayCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    unrankedPlayCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    totalPlayCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageRankedRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageWeightedRankedRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageUnrankedRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    averageRank?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    sspPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    ssPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    spPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    sPlays?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    aPlays?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerScoreStatsHistory
     */
    topPlatform?: string;
    /**
     * 
     * @type {HMD}
     * @memberof PlayerScoreStatsHistory
     */
    topHMD?: HMD;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    dailyImprovements?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    replaysWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerScoreStatsHistory
     */
    watchedReplays?: number;
}
/**
 * 
 * @export
 * @interface PlayerSocial
 */
export interface PlayerSocial {
    /**
     * 
     * @type {number}
     * @memberof PlayerSocial
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerSocial
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerSocial
     */
    link?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerSocial
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerSocial
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerSocial
     */
    playerId?: string;
}
/**
 * 
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {number}
     * @memberof Playlist
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Playlist
     */
    isShared?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    link?: string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    ownerId?: string;
}
/**
 * 
 * @export
 * @interface PrevQualification
 */
export interface PrevQualification {
    /**
     * 
     * @type {number}
     * @memberof PrevQualification
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface ProfanityCheckResult
 */
export interface ProfanityCheckResult {
    /**
     * 
     * @type {string}
     * @memberof ProfanityCheckResult
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfanityCheckResult
     */
    intensity?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfanityCheckResult
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfanityCheckResult
     */
    line?: string;
}
/**
 * 
 * @export
 * @interface ProfileSettings
 */
export interface ProfileSettings {
    /**
     * 
     * @type {number}
     * @memberof ProfileSettings
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    bio?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    effectName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    profileAppearance?: string;
    /**
     * 
     * @type {number}
     * @memberof ProfileSettings
     */
    hue?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileSettings
     */
    saturation?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    leftSaberColor?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    rightSaberColor?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    profileCover?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileSettings
     */
    starredFriends?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileSettings
     */
    showBots?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileSettings
     */
    showAllRatings?: boolean;
}
/**
 * 
 * @export
 * @interface QualificationChange
 */
export interface QualificationChange {
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof QualificationChange
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldRankability?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldStars?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldType?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    oldCriteriaMet?: number;
    /**
     * 
     * @type {string}
     * @memberof QualificationChange
     */
    oldCriteriaCommentary?: string;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof QualificationChange
     */
    oldModifiers?: ModifiersMap;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newRankability?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newStars?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newAccRating?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newPassRating?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newTechRating?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newType?: number;
    /**
     * 
     * @type {number}
     * @memberof QualificationChange
     */
    newCriteriaMet?: number;
    /**
     * 
     * @type {string}
     * @memberof QualificationChange
     */
    newCriteriaCommentary?: string;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof QualificationChange
     */
    newModifiers?: ModifiersMap;
}
/**
 * 
 * @export
 * @interface QualificationCommentary
 */
export interface QualificationCommentary {
    /**
     * 
     * @type {number}
     * @memberof QualificationCommentary
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof QualificationCommentary
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof QualificationCommentary
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof QualificationCommentary
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof QualificationCommentary
     */
    editTimeset?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QualificationCommentary
     */
    edited?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QualificationCommentary
     */
    rankQualificationId?: number;
    /**
     * 
     * @type {RankQualification}
     * @memberof QualificationCommentary
     */
    rankQualification?: RankQualification;
    /**
     * 
     * @type {string}
     * @memberof QualificationCommentary
     */
    discordMessageId?: string;
}
/**
 * 
 * @export
 * @interface QualificationVote
 */
export interface QualificationVote {
    /**
     * 
     * @type {number}
     * @memberof QualificationVote
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof QualificationVote
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof QualificationVote
     */
    timeset?: number;
    /**
     * 
     * @type {MapQuality}
     * @memberof QualificationVote
     */
    value?: MapQuality;
    /**
     * 
     * @type {number}
     * @memberof QualificationVote
     */
    editTimeset?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QualificationVote
     */
    edited?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QualificationVote
     */
    rankQualificationId?: number;
    /**
     * 
     * @type {RankQualification}
     * @memberof QualificationVote
     */
    rankQualification?: RankQualification;
    /**
     * 
     * @type {string}
     * @memberof QualificationVote
     */
    discordRTMessageId?: string;
}
/**
 * 
 * @export
 * @interface RankQualification
 */
export interface RankQualification {
    /**
     * 
     * @type {number}
     * @memberof RankQualification
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof RankQualification
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    rtMember?: string;
    /**
     * 
     * @type {number}
     * @memberof RankQualification
     */
    criteriaTimeset?: number;
    /**
     * 
     * @type {number}
     * @memberof RankQualification
     */
    criteriaMet?: number;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    criteriaChecker?: string;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    criteriaCommentary?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RankQualification
     */
    mapperAllowed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    mapperId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RankQualification
     */
    mapperQualification?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RankQualification
     */
    approvalTimeset?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RankQualification
     */
    approved?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    approvers?: string;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    criteriaCheck?: string;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof RankQualification
     */
    modifiers?: ModifiersMap;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof RankQualification
     */
    modifiersRating?: ModifiersRating;
    /**
     * 
     * @type {Array<QualificationChange>}
     * @memberof RankQualification
     */
    changes?: Array<QualificationChange>;
    /**
     * 
     * @type {Array<QualificationCommentary>}
     * @memberof RankQualification
     */
    comments?: Array<QualificationCommentary>;
    /**
     * 
     * @type {Array<CriteriaCommentary>}
     * @memberof RankQualification
     */
    criteriaComments?: Array<CriteriaCommentary>;
    /**
     * 
     * @type {number}
     * @memberof RankQualification
     */
    qualityVote?: number;
    /**
     * 
     * @type {Array<QualificationVote>}
     * @memberof RankQualification
     */
    votes?: Array<QualificationVote>;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    discordChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof RankQualification
     */
    discordRTChannelId?: string;
}
/**
 * 
 * @export
 * @interface RankUpdate
 */
export interface RankUpdate {
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof RankUpdate
     */
    rtMember?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RankUpdate
     */
    keep?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    stars?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    passRating?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    techRating?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    predictedAcc?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdate
     */
    criteriaMet?: number;
    /**
     * 
     * @type {string}
     * @memberof RankUpdate
     */
    criteriaCommentary?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RankUpdate
     */
    finished?: boolean;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof RankUpdate
     */
    modifiers?: ModifiersMap;
    /**
     * 
     * @type {ModifiersRating}
     * @memberof RankUpdate
     */
    modifiersRating?: ModifiersRating;
    /**
     * 
     * @type {Array<RankUpdateChange>}
     * @memberof RankUpdate
     */
    changes?: Array<RankUpdateChange>;
}
/**
 * 
 * @export
 * @interface RankUpdateChange
 */
export interface RankUpdateChange {
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    timeset?: number;
    /**
     * 
     * @type {string}
     * @memberof RankUpdateChange
     */
    playerId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RankUpdateChange
     */
    oldKeep?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    oldStars?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    oldType?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    oldCriteriaMet?: number;
    /**
     * 
     * @type {string}
     * @memberof RankUpdateChange
     */
    oldCriteriaCommentary?: string;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof RankUpdateChange
     */
    oldModifiers?: ModifiersMap;
    /**
     * 
     * @type {boolean}
     * @memberof RankUpdateChange
     */
    newKeep?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    newStars?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    newType?: number;
    /**
     * 
     * @type {number}
     * @memberof RankUpdateChange
     */
    newCriteriaMet?: number;
    /**
     * 
     * @type {string}
     * @memberof RankUpdateChange
     */
    newCriteriaCommentary?: string;
    /**
     * 
     * @type {ModifiersMap}
     * @memberof RankUpdateChange
     */
    newModifiers?: ModifiersMap;
}
/**
 * 
 * @export
 * @interface RankVoting
 */
export interface RankVoting {
    /**
     * 
     * @type {number}
     * @memberof RankVoting
     */
    scoreId?: number;
    /**
     * 
     * @type {string}
     * @memberof RankVoting
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof RankVoting
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof RankVoting
     */
    diff?: string;
    /**
     * 
     * @type {string}
     * @memberof RankVoting
     */
    mode?: string;
    /**
     * 
     * @type {number}
     * @memberof RankVoting
     */
    rankability?: number;
    /**
     * 
     * @type {number}
     * @memberof RankVoting
     */
    stars?: number;
    /**
     * 
     * @type {number}
     * @memberof RankVoting
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof RankVoting
     */
    timeset?: number;
    /**
     * 
     * @type {Array<VoterFeedback>}
     * @memberof RankVoting
     */
    feedbacks?: Array<VoterFeedback>;
}
/**
 * 
 * @export
 * @interface ReplayOffsets
 */
export interface ReplayOffsets {
    /**
     * 
     * @type {number}
     * @memberof ReplayOffsets
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplayOffsets
     */
    frames?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplayOffsets
     */
    notes?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplayOffsets
     */
    walls?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplayOffsets
     */
    heights?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplayOffsets
     */
    pauses?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Requirements {
    NUMBER_0 = <any> 0,
    NUMBER_2 = <any> 2,
    NUMBER_4 = <any> 4,
    NUMBER_8 = <any> 8,
    NUMBER_16 = <any> 16,
    NUMBER_32 = <any> 32,
    NUMBER_MINUS_1 = <any> -1
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum S3Container {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4,
    NUMBER_5 = <any> 5,
    NUMBER_6 = <any> 6
}
/**
 * 
 * @export
 * @interface SaverContainerResponse
 */
export interface SaverContainerResponse {
    /**
     * 
     * @type {string}
     * @memberof SaverContainerResponse
     */
    leaderboardId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaverContainerResponse
     */
    ranked?: boolean;
}
/**
 * 
 * @export
 * @interface SaverScoreResponse
 */
export interface SaverScoreResponse {
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof SaverScoreResponse
     */
    modifiers?: string;
    /**
     * 
     * @type {string}
     * @memberof SaverScoreResponse
     */
    leaderboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof SaverScoreResponse
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof SaverScoreResponse
     */
    timepost?: number;
    /**
     * 
     * @type {string}
     * @memberof SaverScoreResponse
     */
    player?: string;
}
/**
 * 
 * @export
 * @interface SaverScoreResponseResponseWithMetadata
 */
export interface SaverScoreResponseResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof SaverScoreResponseResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<SaverScoreResponse>}
     * @memberof SaverScoreResponseResponseWithMetadata
     */
    data?: Array<SaverScoreResponse>;
}
/**
 * 
 * @export
 * @interface SaverScoreResponseSaverContainerResponseResponseWithMetadataAndContainer
 */
export interface SaverScoreResponseSaverContainerResponseResponseWithMetadataAndContainer {
    /**
     * 
     * @type {Metadata}
     * @memberof SaverScoreResponseSaverContainerResponseResponseWithMetadataAndContainer
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<SaverScoreResponse>}
     * @memberof SaverScoreResponseSaverContainerResponseResponseWithMetadataAndContainer
     */
    data?: Array<SaverScoreResponse>;
    /**
     * 
     * @type {SaverContainerResponse}
     * @memberof SaverScoreResponseSaverContainerResponseResponseWithMetadataAndContainer
     */
    container?: SaverContainerResponse;
}
/**
 * 
 * @export
 * @interface Score
 */
export interface Score {
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    bonusPp?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    passPP?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    accPP?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    techPP?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    qualification?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    countryRank?: number;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    replay?: string;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    modifiers?: string;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    badCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    bombCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    wallsHit?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    pauses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    fullCombo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    maxCombo?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    fcAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    fcPp?: number;
    /**
     * 
     * @type {HMD}
     * @memberof Score
     */
    hmd?: HMD;
    /**
     * 
     * @type {ControllerEnum}
     * @memberof Score
     */
    controller?: ControllerEnum;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    accRight?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    accLeft?: number;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    timepost?: number;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    platform?: string;
    /**
     * 
     * @type {Player}
     * @memberof Score
     */
    player?: Player;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    leaderboardId?: string;
    /**
     * 
     * @type {Leaderboard}
     * @memberof Score
     */
    leaderboard?: Leaderboard;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    authorizedReplayWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    anonimusReplayWatched?: number;
    /**
     * 
     * @type {ReplayOffsets}
     * @memberof Score
     */
    replayOffsets?: ReplayOffsets;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    maxStreak?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    playCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    leftTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    rightTiming?: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    priority?: number;
    /**
     * 
     * @type {ScoreImprovement}
     * @memberof Score
     */
    scoreImprovement?: ScoreImprovement;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    banned?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    suspicious?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    bot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    ignoreForStats?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    migrated?: boolean;
    /**
     * 
     * @type {RankVoting}
     * @memberof Score
     */
    rankVoting?: RankVoting;
    /**
     * 
     * @type {ScoreMetadata}
     * @memberof Score
     */
    metadata?: ScoreMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ScoreFilterStatus {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1
}
/**
 * 
 * @export
 * @interface ScoreGraphTracker
 */
export interface ScoreGraphTracker {
    /**
     * 
     * @type {Array<number>}
     * @memberof ScoreGraphTracker
     */
    graph?: Array<number>;
}
/**
 * 
 * @export
 * @interface ScoreImprovement
 */
export interface ScoreImprovement {
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreImprovement
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    score?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    bonusPp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    accRight?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    accLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    averageRankedAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    totalPp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    totalRank?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    badCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    bombCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    wallsHit?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreImprovement
     */
    pauses?: number;
}
/**
 * 
 * @export
 * @interface ScoreMetadata
 */
export interface ScoreMetadata {
    /**
     * 
     * @type {number}
     * @memberof ScoreMetadata
     */
    id?: number;
    /**
     * 
     * @type {ScoreStatus}
     * @memberof ScoreMetadata
     */
    status?: ScoreStatus;
    /**
     * 
     * @type {number}
     * @memberof ScoreMetadata
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreMetadata
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreMetadata
     */
    linkService?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreMetadata
     */
    linkServiceIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreMetadata
     */
    link?: string;
}
/**
 * 
 * @export
 * @interface ScoreResponse
 */
export interface ScoreResponse {
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    bonusPp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    passPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    accPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    techPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    fcAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    fcPp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    weight?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    replay?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    modifiers?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    badCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    bombCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    wallsHit?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    pauses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreResponse
     */
    fullCombo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    platform?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    maxCombo?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    maxStreak?: number;
    /**
     * 
     * @type {HMD}
     * @memberof ScoreResponse
     */
    hmd?: HMD;
    /**
     * 
     * @type {ControllerEnum}
     * @memberof ScoreResponse
     */
    controller?: ControllerEnum;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    leaderboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponse
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    timepost?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    replaysWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponse
     */
    playCount?: number;
    /**
     * 
     * @type {PlayerResponse}
     * @memberof ScoreResponse
     */
    player?: PlayerResponse;
    /**
     * 
     * @type {ScoreImprovement}
     * @memberof ScoreResponse
     */
    scoreImprovement?: ScoreImprovement;
    /**
     * 
     * @type {RankVoting}
     * @memberof ScoreResponse
     */
    rankVoting?: RankVoting;
    /**
     * 
     * @type {ScoreMetadata}
     * @memberof ScoreResponse
     */
    metadata?: ScoreMetadata;
    /**
     * 
     * @type {ReplayOffsets}
     * @memberof ScoreResponse
     */
    offsets?: ReplayOffsets;
}
/**
 * 
 * @export
 * @interface ScoreResponseResponseWithMetadataAndSelection
 */
export interface ScoreResponseResponseWithMetadataAndSelection {
    /**
     * 
     * @type {Metadata}
     * @memberof ScoreResponseResponseWithMetadataAndSelection
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<ScoreResponse>}
     * @memberof ScoreResponseResponseWithMetadataAndSelection
     */
    data?: Array<ScoreResponse>;
    /**
     * 
     * @type {ScoreResponse}
     * @memberof ScoreResponseResponseWithMetadataAndSelection
     */
    selection?: ScoreResponse;
}
/**
 * 
 * @export
 * @interface ScoreResponseWithAcc
 */
export interface ScoreResponseWithAcc {
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    bonusPp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    passPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    accPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    techPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    fcAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    fcPp?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    replay?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    modifiers?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    badCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    bombCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    wallsHit?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    pauses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreResponseWithAcc
     */
    fullCombo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    platform?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    maxCombo?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    maxStreak?: number;
    /**
     * 
     * @type {HMD}
     * @memberof ScoreResponseWithAcc
     */
    hmd?: HMD;
    /**
     * 
     * @type {ControllerEnum}
     * @memberof ScoreResponseWithAcc
     */
    controller?: ControllerEnum;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    leaderboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithAcc
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    timepost?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    replaysWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    playCount?: number;
    /**
     * 
     * @type {PlayerResponse}
     * @memberof ScoreResponseWithAcc
     */
    player?: PlayerResponse;
    /**
     * 
     * @type {ScoreImprovement}
     * @memberof ScoreResponseWithAcc
     */
    scoreImprovement?: ScoreImprovement;
    /**
     * 
     * @type {RankVoting}
     * @memberof ScoreResponseWithAcc
     */
    rankVoting?: RankVoting;
    /**
     * 
     * @type {ScoreMetadata}
     * @memberof ScoreResponseWithAcc
     */
    metadata?: ScoreMetadata;
    /**
     * 
     * @type {ReplayOffsets}
     * @memberof ScoreResponseWithAcc
     */
    offsets?: ReplayOffsets;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    accLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithAcc
     */
    accRight?: number;
}
/**
 * 
 * @export
 * @interface ScoreResponseWithMyScore
 */
export interface ScoreResponseWithMyScore {
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    baseScore?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    modifiedScore?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    bonusPp?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    passPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    accPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    techPP?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    fcAccuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    fcPp?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    replay?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    modifiers?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    badCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    missedNotes?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    bombCuts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    wallsHit?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    pauses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreResponseWithMyScore
     */
    fullCombo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    platform?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    maxCombo?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    maxStreak?: number;
    /**
     * 
     * @type {HMD}
     * @memberof ScoreResponseWithMyScore
     */
    hmd?: HMD;
    /**
     * 
     * @type {ControllerEnum}
     * @memberof ScoreResponseWithMyScore
     */
    controller?: ControllerEnum;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    leaderboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreResponseWithMyScore
     */
    timeset?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    timepost?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    replaysWatched?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    playCount?: number;
    /**
     * 
     * @type {PlayerResponse}
     * @memberof ScoreResponseWithMyScore
     */
    player?: PlayerResponse;
    /**
     * 
     * @type {ScoreImprovement}
     * @memberof ScoreResponseWithMyScore
     */
    scoreImprovement?: ScoreImprovement;
    /**
     * 
     * @type {RankVoting}
     * @memberof ScoreResponseWithMyScore
     */
    rankVoting?: RankVoting;
    /**
     * 
     * @type {ScoreMetadata}
     * @memberof ScoreResponseWithMyScore
     */
    metadata?: ScoreMetadata;
    /**
     * 
     * @type {ReplayOffsets}
     * @memberof ScoreResponseWithMyScore
     */
    offsets?: ReplayOffsets;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    accLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreResponseWithMyScore
     */
    accRight?: number;
    /**
     * 
     * @type {ScoreResponseWithAcc}
     * @memberof ScoreResponseWithMyScore
     */
    myScore?: ScoreResponseWithAcc;
    /**
     * 
     * @type {LeaderboardResponse}
     * @memberof ScoreResponseWithMyScore
     */
    leaderboard?: LeaderboardResponse;
}
/**
 * 
 * @export
 * @interface ScoreResponseWithMyScoreResponseWithMetadata
 */
export interface ScoreResponseWithMyScoreResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof ScoreResponseWithMyScoreResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<ScoreResponseWithMyScore>}
     * @memberof ScoreResponseWithMyScoreResponseWithMetadata
     */
    data?: Array<ScoreResponseWithMyScore>;
}
/**
 * 
 * @export
 * @interface ScoreStatistic
 */
export interface ScoreStatistic {
    /**
     * 
     * @type {HitTracker}
     * @memberof ScoreStatistic
     */
    hitTracker?: HitTracker;
    /**
     * 
     * @type {AccuracyTracker}
     * @memberof ScoreStatistic
     */
    accuracyTracker?: AccuracyTracker;
    /**
     * 
     * @type {WinTracker}
     * @memberof ScoreStatistic
     */
    winTracker?: WinTracker;
    /**
     * 
     * @type {ScoreGraphTracker}
     * @memberof ScoreStatistic
     */
    scoreGraphTracker?: ScoreGraphTracker;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ScoreStatus {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1
}
/**
 * 
 * @export
 * @interface SigninApproveBody
 */
export interface SigninApproveBody {
    /**
     * 
     * @type {string}
     * @memberof SigninApproveBody
     */
    returnUrl?: string;
}
/**
 * 
 * @export
 * @interface SigninBody
 */
export interface SigninBody {
    /**
     * 
     * @type {string}
     * @memberof SigninBody
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof SigninBody
     */
    returnUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof SigninBody
     */
    oauthState?: string;
}
/**
 * 
 * @export
 * @interface SigninmigrateBody
 */
export interface SigninmigrateBody {
    /**
     * 
     * @type {string}
     * @memberof SigninmigrateBody
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof SigninmigrateBody
     */
    returnUrl?: string;
}
/**
 * 
 * @export
 * @interface SigninmigrateOculuspcBody
 */
export interface SigninmigrateOculuspcBody {
    /**
     * 
     * @type {string}
     * @memberof SigninmigrateOculuspcBody
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof SigninmigrateOculuspcBody
     */
    returnUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof SigninmigrateOculuspcBody
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface SigninoculusBody
 */
export interface SigninoculusBody {
    /**
     * 
     * @type {string}
     * @memberof SigninoculusBody
     */
    oauthState?: string;
}
/**
 * 
 * @export
 * @interface SigninoculusOculuspcBody
 */
export interface SigninoculusOculuspcBody {
    /**
     * 
     * @type {string}
     * @memberof SigninoculusOculuspcBody
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof SigninoculusOculuspcBody
     */
    returnUrl?: string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    subName?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    mapper?: string;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    mapperId?: number;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    coverImage?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    fullCoverImage?: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    downloadUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    bpm?: number;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    tags?: string;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    uploadTime?: number;
    /**
     * 
     * @type {Array<DifficultyDescription>}
     * @memberof Song
     */
    difficulties?: Array<DifficultyDescription>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortBy {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4,
    NUMBER_5 = <any> 5,
    NUMBER_6 = <any> 6,
    NUMBER_7 = <any> 7,
    NUMBER_8 = <any> 8,
    NUMBER_9 = <any> 9,
    NUMBER_10 = <any> 10,
    NUMBER_11 = <any> 11,
    NUMBER_12 = <any> 12
}
/**
 * 
 * @export
 * @interface StringResponseWithMetadata
 */
export interface StringResponseWithMetadata {
    /**
     * 
     * @type {Metadata}
     * @memberof StringResponseWithMetadata
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<string>}
     * @memberof StringResponseWithMetadata
     */
    data?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Type {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3,
    NUMBER_4 = <any> 4,
    NUMBER_5 = <any> 5,
    NUMBER_6 = <any> 6,
    NUMBER_7 = <any> 7,
    NUMBER_8 = <any> 8
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {Player}
     * @memberof User
     */
    player?: Player;
    /**
     * 
     * @type {Array<Clan>}
     * @memberof User
     */
    clanRequest?: Array<Clan>;
    /**
     * 
     * @type {Array<Clan>}
     * @memberof User
     */
    bannedClans?: Array<Clan>;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof User
     */
    playlists?: Array<Playlist>;
}
/**
 * 
 * @export
 * @interface UserChangeLoginBody
 */
export interface UserChangeLoginBody {
    /**
     * 
     * @type {string}
     * @memberof UserChangeLoginBody
     */
    newLogin?: string;
}
/**
 * 
 * @export
 * @interface UserChangePasswordBody
 */
export interface UserChangePasswordBody {
    /**
     * 
     * @type {string}
     * @memberof UserChangePasswordBody
     */
    login?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChangePasswordBody
     */
    oldPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChangePasswordBody
     */
    newPassword?: string;
}
/**
 * 
 * @export
 * @interface UserMigrateBody
 */
export interface UserMigrateBody {
    /**
     * 
     * @type {string}
     * @memberof UserMigrateBody
     */
    login?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMigrateBody
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface UserResetPasswordBody
 */
export interface UserResetPasswordBody {
    /**
     * 
     * @type {string}
     * @memberof UserResetPasswordBody
     */
    login?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResetPasswordBody
     */
    newPassword?: string;
}
/**
 * 
 * @export
 * @interface UserReturn
 */
export interface UserReturn {
    /**
     * 
     * @type {PlayerResponseFull}
     * @memberof UserReturn
     */
    player?: PlayerResponseFull;
    /**
     * 
     * @type {ClanReturn}
     * @memberof UserReturn
     */
    clan?: ClanReturn;
    /**
     * 
     * @type {BanReturn}
     * @memberof UserReturn
     */
    ban?: BanReturn;
    /**
     * 
     * @type {Array<Clan>}
     * @memberof UserReturn
     */
    clanRequest?: Array<Clan>;
    /**
     * 
     * @type {Array<Clan>}
     * @memberof UserReturn
     */
    bannedClans?: Array<Clan>;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof UserReturn
     */
    playlists?: Array<Playlist>;
    /**
     * 
     * @type {Array<PlayerResponseFull>}
     * @memberof UserReturn
     */
    friends?: Array<PlayerResponseFull>;
    /**
     * 
     * @type {string}
     * @memberof UserReturn
     */
    login?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserReturn
     */
    migrated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserReturn
     */
    patreoned?: boolean;
}
/**
 * 
 * @export
 * @interface UserUnlinkBody
 */
export interface UserUnlinkBody {
    /**
     * 
     * @type {string}
     * @memberof UserUnlinkBody
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUnlinkBody
     */
    returnUrl?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum VoteStatus {
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3
}
/**
 * 
 * @export
 * @interface VoterFeedback
 */
export interface VoterFeedback {
    /**
     * 
     * @type {number}
     * @memberof VoterFeedback
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VoterFeedback
     */
    rtMember?: string;
    /**
     * 
     * @type {number}
     * @memberof VoterFeedback
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface WinTracker
 */
export interface WinTracker {
    /**
     * 
     * @type {boolean}
     * @memberof WinTracker
     */
    won?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    endTime?: number;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    nbOfPause?: number;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    totalPauseDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    jumpDistance?: number;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    averageHeight?: number;
    /**
     * 
     * @type {AveragePosition}
     * @memberof WinTracker
     */
    averageHeadPosition?: AveragePosition;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    totalScore?: number;
    /**
     * 
     * @type {number}
     * @memberof WinTracker
     */
    maxScore?: number;
}
/**
 * AchievementsApi - fetch parameter creator
 * @export
 */
export const AchievementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} [name] 
         * @param {string} [image] 
         * @param {string} [smallImage] 
         * @param {number} [level] 
         * @param {string} [description] 
         * @param {string} [detailedDescription] 
         * @param {string} [color] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementIdLevelPut(id: number, name?: string, image?: string, smallImage?: string, level?: number, description?: string, detailedDescription?: string, color?: string, link?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling achievementIdLevelPut.');
            }
            const localVarPath = `/achievement/{id}/level`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (smallImage !== undefined) {
                localVarQueryParameter['smallImage'] = smallImage;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (detailedDescription !== undefined) {
                localVarQueryParameter['detailedDescription'] = detailedDescription;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementPut(name?: string, description?: string, link?: string, options: any = {}): FetchArgs {
            const localVarPath = `/achievement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsGet(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/achievements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [achievemntId] 
         * @param {number} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAchievementPost(id: string, achievemntId?: number, level?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdAchievementPost.');
            }
            const localVarPath = `/player/{id}/achievement`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (achievemntId !== undefined) {
                localVarQueryParameter['achievemntId'] = achievemntId;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAchievementsGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdAchievementsGet.');
            }
            const localVarPath = `/player/{id}/achievements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveyAchievementGet(options: any = {}): FetchArgs {
            const localVarPath = `/survey/achievement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveyFilledPost(playerId?: string, key?: string, options: any = {}): FetchArgs {
            const localVarPath = `/survey/filled`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AchievementsApi - functional programming interface
 * @export
 */
export const AchievementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} [name] 
         * @param {string} [image] 
         * @param {string} [smallImage] 
         * @param {number} [level] 
         * @param {string} [description] 
         * @param {string} [detailedDescription] 
         * @param {string} [color] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementIdLevelPut(id: number, name?: string, image?: string, smallImage?: string, level?: number, description?: string, detailedDescription?: string, color?: string, link?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchievementLevel> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).achievementIdLevelPut(id, name, image, smallImage, level, description, detailedDescription, color, link, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementPut(name?: string, description?: string, link?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchievementDescription> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).achievementPut(name, description, link, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsGet(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AchievementDescription>> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).achievementsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [achievemntId] 
         * @param {number} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAchievementPost(id: string, achievemntId?: number, level?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Achievement> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).playerIdAchievementPost(id, achievemntId, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAchievementsGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Achievement>> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).playerIdAchievementsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveyAchievementGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Achievement> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).surveyAchievementGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveyFilledPost(playerId?: string, key?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AchievementsApiFetchParamCreator(configuration).surveyFilledPost(playerId, key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AchievementsApi - factory interface
 * @export
 */
export const AchievementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} [name] 
         * @param {string} [image] 
         * @param {string} [smallImage] 
         * @param {number} [level] 
         * @param {string} [description] 
         * @param {string} [detailedDescription] 
         * @param {string} [color] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementIdLevelPut(id: number, name?: string, image?: string, smallImage?: string, level?: number, description?: string, detailedDescription?: string, color?: string, link?: string, options?: any) {
            return AchievementsApiFp(configuration).achievementIdLevelPut(id, name, image, smallImage, level, description, detailedDescription, color, link, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementPut(name?: string, description?: string, link?: string, options?: any) {
            return AchievementsApiFp(configuration).achievementPut(name, description, link, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsGet(id?: string, options?: any) {
            return AchievementsApiFp(configuration).achievementsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [achievemntId] 
         * @param {number} [level] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAchievementPost(id: string, achievemntId?: number, level?: number, options?: any) {
            return AchievementsApiFp(configuration).playerIdAchievementPost(id, achievemntId, level, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAchievementsGet(id: string, options?: any) {
            return AchievementsApiFp(configuration).playerIdAchievementsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveyAchievementGet(options?: any) {
            return AchievementsApiFp(configuration).surveyAchievementGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        surveyFilledPost(playerId?: string, key?: string, options?: any) {
            return AchievementsApiFp(configuration).surveyFilledPost(playerId, key, options)(fetch, basePath);
        },
    };
};

/**
 * AchievementsApi - object-oriented interface
 * @export
 * @class AchievementsApi
 * @extends {BaseAPI}
 */
export class AchievementsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {string} [name] 
     * @param {string} [image] 
     * @param {string} [smallImage] 
     * @param {number} [level] 
     * @param {string} [description] 
     * @param {string} [detailedDescription] 
     * @param {string} [color] 
     * @param {string} [link] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public achievementIdLevelPut(id: number, name?: string, image?: string, smallImage?: string, level?: number, description?: string, detailedDescription?: string, color?: string, link?: string, options?: any) {
        return AchievementsApiFp(this.configuration).achievementIdLevelPut(id, name, image, smallImage, level, description, detailedDescription, color, link, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [link] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public achievementPut(name?: string, description?: string, link?: string, options?: any) {
        return AchievementsApiFp(this.configuration).achievementPut(name, description, link, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public achievementsGet(id?: string, options?: any) {
        return AchievementsApiFp(this.configuration).achievementsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [achievemntId] 
     * @param {number} [level] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public playerIdAchievementPost(id: string, achievemntId?: number, level?: number, options?: any) {
        return AchievementsApiFp(this.configuration).playerIdAchievementPost(id, achievemntId, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public playerIdAchievementsGet(id: string, options?: any) {
        return AchievementsApiFp(this.configuration).playerIdAchievementsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public surveyAchievementGet(options?: any) {
        return AchievementsApiFp(this.configuration).surveyAchievementGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [playerId] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public surveyFilledPost(playerId?: string, key?: string, options?: any) {
        return AchievementsApiFp(this.configuration).surveyFilledPost(playerId, key, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizePost(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2IdentityGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/identity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthclientAntiforgeryGet(options: any = {}): FetchArgs {
            const localVarPath = `/oauthclient/antiforgery`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthclientInfoGet(clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/oauthclient/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinApprovePost(returnUrl?: string, leaderboardId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/signin/approve`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (leaderboardId !== undefined) {
                localVarQueryParameter['leaderboardId'] = leaderboardId;
            }

            if (returnUrl !== undefined) {
                localVarFormParams.set('returnUrl', returnUrl as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinGet(options: any = {}): FetchArgs {
            const localVarPath = `/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(provider?: string, returnUrl?: string, oauthState?: string, options: any = {}): FetchArgs {
            const localVarPath = `/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (provider !== undefined) {
                localVarFormParams.set('provider', provider as any);
            }

            if (returnUrl !== undefined) {
                localVarFormParams.set('returnUrl', returnUrl as any);
            }

            if (oauthState !== undefined) {
                localVarFormParams.set('oauthState', oauthState as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinmigrateOculuspcPost(provider?: string, returnUrl?: string, token?: string, options: any = {}): FetchArgs {
            const localVarPath = `/signinmigrate/oculuspc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (provider !== undefined) {
                localVarFormParams.set('provider', provider as any);
            }

            if (returnUrl !== undefined) {
                localVarFormParams.set('returnUrl', returnUrl as any);
            }

            if (token !== undefined) {
                localVarFormParams.set('token', token as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinmigratePost(provider?: string, returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/signinmigrate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (provider !== undefined) {
                localVarFormParams.set('provider', provider as any);
            }

            if (returnUrl !== undefined) {
                localVarFormParams.set('returnUrl', returnUrl as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [token] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinoculusOculuspcPost(token?: string, returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/signinoculus/oculuspc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (token !== undefined) {
                localVarFormParams.set('token', token as any);
            }

            if (returnUrl !== undefined) {
                localVarFormParams.set('returnUrl', returnUrl as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinoculusPost(oauthState?: string, options: any = {}): FetchArgs {
            const localVarPath = `/signinoculus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (oauthState !== undefined) {
                localVarFormParams.set('oauthState', oauthState as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutGet(options: any = {}): FetchArgs {
            const localVarPath = `/signout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options: any = {}): FetchArgs {
            const localVarPath = `/signout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {number} [random] 
         * @param {string} [migrateTo] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamcallbackGet(returnUrl?: string, random?: number, migrateTo?: string, oauthState?: string, options: any = {}): FetchArgs {
            const localVarPath = `/steamcallback`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['ReturnUrl'] = returnUrl;
            }

            if (random !== undefined) {
                localVarQueryParameter['Random'] = random;
            }

            if (migrateTo !== undefined) {
                localVarQueryParameter['migrateTo'] = migrateTo;
            }

            if (oauthState !== undefined) {
                localVarQueryParameter['oauthState'] = oauthState;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).oauth2AuthorizeGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizePost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).oauth2AuthorizePost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2IdentityGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).oauth2IdentityGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthclientAntiforgeryGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).oauthclientAntiforgeryGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthclientInfoGet(clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OauthClientInfo> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).oauthclientInfoGet(clientId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinApprovePost(returnUrl?: string, leaderboardId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinApprovePost(returnUrl, leaderboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(provider?: string, returnUrl?: string, oauthState?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinPost(provider, returnUrl, oauthState, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinmigrateOculuspcPost(provider?: string, returnUrl?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinmigrateOculuspcPost(provider, returnUrl, token, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinmigratePost(provider?: string, returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinmigratePost(provider, returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [token] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinoculusOculuspcPost(token?: string, returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinoculusOculuspcPost(token, returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinoculusPost(oauthState?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signinoculusPost(oauthState, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signoutGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signoutPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {number} [random] 
         * @param {string} [migrateTo] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamcallbackGet(returnUrl?: string, random?: number, migrateTo?: string, oauthState?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).steamcallbackGet(returnUrl, random, migrateTo, oauthState, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeGet(options?: any) {
            return AuthenticationApiFp(configuration).oauth2AuthorizeGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizePost(options?: any) {
            return AuthenticationApiFp(configuration).oauth2AuthorizePost(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2IdentityGet(options?: any) {
            return AuthenticationApiFp(configuration).oauth2IdentityGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthclientAntiforgeryGet(options?: any) {
            return AuthenticationApiFp(configuration).oauthclientAntiforgeryGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthclientInfoGet(clientId?: string, options?: any) {
            return AuthenticationApiFp(configuration).oauthclientInfoGet(clientId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinApprovePost(returnUrl?: string, leaderboardId?: string, options?: any) {
            return AuthenticationApiFp(configuration).signinApprovePost(returnUrl, leaderboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinGet(options?: any) {
            return AuthenticationApiFp(configuration).signinGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinPost(provider?: string, returnUrl?: string, oauthState?: string, options?: any) {
            return AuthenticationApiFp(configuration).signinPost(provider, returnUrl, oauthState, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinmigrateOculuspcPost(provider?: string, returnUrl?: string, token?: string, options?: any) {
            return AuthenticationApiFp(configuration).signinmigrateOculuspcPost(provider, returnUrl, token, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinmigratePost(provider?: string, returnUrl?: string, options?: any) {
            return AuthenticationApiFp(configuration).signinmigratePost(provider, returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [token] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinoculusOculuspcPost(token?: string, returnUrl?: string, options?: any) {
            return AuthenticationApiFp(configuration).signinoculusOculuspcPost(token, returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinoculusPost(oauthState?: string, options?: any) {
            return AuthenticationApiFp(configuration).signinoculusPost(oauthState, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutGet(options?: any) {
            return AuthenticationApiFp(configuration).signoutGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signoutPost(options?: any) {
            return AuthenticationApiFp(configuration).signoutPost(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {number} [random] 
         * @param {string} [migrateTo] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamcallbackGet(returnUrl?: string, random?: number, migrateTo?: string, oauthState?: string, options?: any) {
            return AuthenticationApiFp(configuration).steamcallbackGet(returnUrl, random, migrateTo, oauthState, options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauth2AuthorizeGet(options?: any) {
        return AuthenticationApiFp(this.configuration).oauth2AuthorizeGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauth2AuthorizePost(options?: any) {
        return AuthenticationApiFp(this.configuration).oauth2AuthorizePost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauth2IdentityGet(options?: any) {
        return AuthenticationApiFp(this.configuration).oauth2IdentityGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauthclientAntiforgeryGet(options?: any) {
        return AuthenticationApiFp(this.configuration).oauthclientAntiforgeryGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [clientId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauthclientInfoGet(clientId?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).oauthclientInfoGet(clientId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {string} [leaderboardId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinApprovePost(returnUrl?: string, leaderboardId?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).signinApprovePost(returnUrl, leaderboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinGet(options?: any) {
        return AuthenticationApiFp(this.configuration).signinGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [provider] 
     * @param {string} [returnUrl] 
     * @param {string} [oauthState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinPost(provider?: string, returnUrl?: string, oauthState?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).signinPost(provider, returnUrl, oauthState, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [provider] 
     * @param {string} [returnUrl] 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinmigrateOculuspcPost(provider?: string, returnUrl?: string, token?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).signinmigrateOculuspcPost(provider, returnUrl, token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [provider] 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinmigratePost(provider?: string, returnUrl?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).signinmigratePost(provider, returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [token] 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinoculusOculuspcPost(token?: string, returnUrl?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).signinoculusOculuspcPost(token, returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [oauthState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signinoculusPost(oauthState?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).signinoculusPost(oauthState, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signoutGet(options?: any) {
        return AuthenticationApiFp(this.configuration).signoutGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signoutPost(options?: any) {
        return AuthenticationApiFp(this.configuration).signoutPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {number} [random] 
     * @param {string} [migrateTo] 
     * @param {string} [oauthState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public steamcallbackGet(returnUrl?: string, random?: number, migrateTo?: string, oauthState?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).steamcallbackGet(returnUrl, random, migrateTo, oauthState, options)(this.fetch, this.basePath);
    }

}
/**
 * BackupApi - fetch parameter creator
 * @export
 */
export const BackupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {S3Container} container 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupFileContainerFilenameGet(container: S3Container, filename: string, options: any = {}): FetchArgs {
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling backupFileContainerFilenameGet.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling backupFileContainerFilenameGet.');
            }
            const localVarPath = `/backup/file/{container}/{filename}`
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupApi - functional programming interface
 * @export
 */
export const BackupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {S3Container} container 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupFileContainerFilenameGet(container: S3Container, filename: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BackupApiFetchParamCreator(configuration).backupFileContainerFilenameGet(container, filename, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BackupApi - factory interface
 * @export
 */
export const BackupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {S3Container} container 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupFileContainerFilenameGet(container: S3Container, filename: string, options?: any) {
            return BackupApiFp(configuration).backupFileContainerFilenameGet(container, filename, options)(fetch, basePath);
        },
    };
};

/**
 * BackupApi - object-oriented interface
 * @export
 * @class BackupApi
 * @extends {BaseAPI}
 */
export class BackupApi extends BaseAPI {
    /**
     * 
     * @param {S3Container} container 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public backupFileContainerFilenameGet(container: S3Container, filename: string, options?: any) {
        return BackupApiFp(this.configuration).backupFileContainerFilenameGet(container, filename, options)(this.fetch, this.basePath);
    }

}
/**
 * BeatSaverApi - fetch parameter creator
 * @export
 */
export const BeatSaverApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beatsaverRefreshGet(options: any = {}): FetchArgs {
            const localVarPath = `/beatsaver/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApproveQualificationGet(leaderboardId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/approveQualification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (leaderboardId !== undefined) {
                localVarQueryParameter['leaderboardId'] = leaderboardId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatSaverAndApproveGet(leaderboardId?: string, returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkBeatSaverAndApprove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (leaderboardId !== undefined) {
                localVarQueryParameter['leaderboardId'] = leaderboardId;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatSaverGet(returnUrl?: string, oauthState?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkBeatSaver`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (oauthState !== undefined) {
                localVarQueryParameter['oauthState'] = oauthState;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BeatSaverApi - functional programming interface
 * @export
 */
export const BeatSaverApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beatsaverRefreshGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeatSaverApiFetchParamCreator(configuration).beatsaverRefreshGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApproveQualificationGet(leaderboardId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeatSaverApiFetchParamCreator(configuration).userApproveQualificationGet(leaderboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatSaverAndApproveGet(leaderboardId?: string, returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeatSaverApiFetchParamCreator(configuration).userLinkBeatSaverAndApproveGet(leaderboardId, returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatSaverGet(returnUrl?: string, oauthState?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeatSaverApiFetchParamCreator(configuration).userLinkBeatSaverGet(returnUrl, oauthState, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BeatSaverApi - factory interface
 * @export
 */
export const BeatSaverApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beatsaverRefreshGet(options?: any) {
            return BeatSaverApiFp(configuration).beatsaverRefreshGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApproveQualificationGet(leaderboardId?: string, options?: any) {
            return BeatSaverApiFp(configuration).userApproveQualificationGet(leaderboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatSaverAndApproveGet(leaderboardId?: string, returnUrl?: string, options?: any) {
            return BeatSaverApiFp(configuration).userLinkBeatSaverAndApproveGet(leaderboardId, returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [oauthState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatSaverGet(returnUrl?: string, oauthState?: string, options?: any) {
            return BeatSaverApiFp(configuration).userLinkBeatSaverGet(returnUrl, oauthState, options)(fetch, basePath);
        },
    };
};

/**
 * BeatSaverApi - object-oriented interface
 * @export
 * @class BeatSaverApi
 * @extends {BaseAPI}
 */
export class BeatSaverApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeatSaverApi
     */
    public beatsaverRefreshGet(options?: any) {
        return BeatSaverApiFp(this.configuration).beatsaverRefreshGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [leaderboardId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeatSaverApi
     */
    public userApproveQualificationGet(leaderboardId?: string, options?: any) {
        return BeatSaverApiFp(this.configuration).userApproveQualificationGet(leaderboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [leaderboardId] 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeatSaverApi
     */
    public userLinkBeatSaverAndApproveGet(leaderboardId?: string, returnUrl?: string, options?: any) {
        return BeatSaverApiFp(this.configuration).userLinkBeatSaverAndApproveGet(leaderboardId, returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {string} [oauthState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeatSaverApi
     */
    public userLinkBeatSaverGet(returnUrl?: string, oauthState?: string, options?: any) {
        return BeatSaverApiFp(this.configuration).userLinkBeatSaverGet(returnUrl, oauthState, options)(this.fetch, this.basePath);
    }

}
/**
 * ClanApi - fetch parameter creator
 * @export
 */
export const ClanApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanAcceptPost(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/clan/accept`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanCancelinvitePost(player?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clan/cancelinvite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {string} [color] 
         * @param {string} [description] 
         * @param {string} [bio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanCreatePost(name?: string, tag?: string, color?: string, description?: string, bio?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clan/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (bio !== undefined) {
                localVarQueryParameter['bio'] = bio;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanDelete(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/clan`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanInvitePost(player?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clan/invite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [player] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanKickplayerPost(player?: string, id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/clan/kickplayer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanLeavePost(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/clan/leave`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [color] 
         * @param {string} [description] 
         * @param {string} [bio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanPut(id?: number, name?: string, color?: string, description?: string, bio?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clan`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (bio !== undefined) {
                localVarQueryParameter['bio'] = bio;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {boolean} [ban] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanRejectPost(id?: number, ban?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/clan/reject`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (ban !== undefined) {
                localVarQueryParameter['ban'] = ban;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanReserveDelete(tag?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clan/reserve`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanReservePost(tag?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clan/reserve`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tag 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sort] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanTagGet(tag: string, page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling clanTagGet.');
            }
            const localVarPath = `/clan/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanUnbanPost(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/clan/unban`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sort] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [type] 
         * @param {string} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clansGet(page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClanApi - functional programming interface
 * @export
 */
export const ClanApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanAcceptPost(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanAcceptPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanCancelinvitePost(player?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanCancelinvitePost(player, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {string} [color] 
         * @param {string} [description] 
         * @param {string} [bio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanCreatePost(name?: string, tag?: string, color?: string, description?: string, bio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Clan> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanCreatePost(name, tag, color, description, bio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanDelete(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanInvitePost(player?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanInvitePost(player, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [player] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanKickplayerPost(player?: string, id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanKickplayerPost(player, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanLeavePost(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanLeavePost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [color] 
         * @param {string} [description] 
         * @param {string} [bio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanPut(id?: number, name?: string, color?: string, description?: string, bio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanPut(id, name, color, description, bio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {boolean} [ban] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanRejectPost(id?: number, ban?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanRejectPost(id, ban, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanReserveDelete(tag?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanReserveDelete(tag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanReservePost(tag?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanReservePost(tag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tag 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sort] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanTagGet(tag: string, page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseClanResponseWithMetadataAndContainer> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanTagGet(tag, page, count, sort, order, search, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanUnbanPost(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clanUnbanPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sort] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [type] 
         * @param {string} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clansGet(page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClanResponseWithMetadata> {
            const localVarFetchArgs = ClanApiFetchParamCreator(configuration).clansGet(page, count, sort, order, search, type, sortBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClanApi - factory interface
 * @export
 */
export const ClanApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanAcceptPost(id?: number, options?: any) {
            return ClanApiFp(configuration).clanAcceptPost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanCancelinvitePost(player?: string, options?: any) {
            return ClanApiFp(configuration).clanCancelinvitePost(player, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {string} [color] 
         * @param {string} [description] 
         * @param {string} [bio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanCreatePost(name?: string, tag?: string, color?: string, description?: string, bio?: string, options?: any) {
            return ClanApiFp(configuration).clanCreatePost(name, tag, color, description, bio, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanDelete(id?: number, options?: any) {
            return ClanApiFp(configuration).clanDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanInvitePost(player?: string, options?: any) {
            return ClanApiFp(configuration).clanInvitePost(player, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [player] 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanKickplayerPost(player?: string, id?: number, options?: any) {
            return ClanApiFp(configuration).clanKickplayerPost(player, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanLeavePost(id?: number, options?: any) {
            return ClanApiFp(configuration).clanLeavePost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [color] 
         * @param {string} [description] 
         * @param {string} [bio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanPut(id?: number, name?: string, color?: string, description?: string, bio?: string, options?: any) {
            return ClanApiFp(configuration).clanPut(id, name, color, description, bio, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {boolean} [ban] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanRejectPost(id?: number, ban?: boolean, options?: any) {
            return ClanApiFp(configuration).clanRejectPost(id, ban, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanReserveDelete(tag?: string, options?: any) {
            return ClanApiFp(configuration).clanReserveDelete(tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanReservePost(tag?: string, options?: any) {
            return ClanApiFp(configuration).clanReservePost(tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tag 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sort] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanTagGet(tag: string, page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, options?: any) {
            return ClanApiFp(configuration).clanTagGet(tag, page, count, sort, order, search, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clanUnbanPost(id?: number, options?: any) {
            return ClanApiFp(configuration).clanUnbanPost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sort] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [type] 
         * @param {string} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clansGet(page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, sortBy?: string, options?: any) {
            return ClanApiFp(configuration).clansGet(page, count, sort, order, search, type, sortBy, options)(fetch, basePath);
        },
    };
};

/**
 * ClanApi - object-oriented interface
 * @export
 * @class ClanApi
 * @extends {BaseAPI}
 */
export class ClanApi extends BaseAPI {
    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanAcceptPost(id?: number, options?: any) {
        return ClanApiFp(this.configuration).clanAcceptPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanCancelinvitePost(player?: string, options?: any) {
        return ClanApiFp(this.configuration).clanCancelinvitePost(player, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {string} [tag] 
     * @param {string} [color] 
     * @param {string} [description] 
     * @param {string} [bio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanCreatePost(name?: string, tag?: string, color?: string, description?: string, bio?: string, options?: any) {
        return ClanApiFp(this.configuration).clanCreatePost(name, tag, color, description, bio, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanDelete(id?: number, options?: any) {
        return ClanApiFp(this.configuration).clanDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanInvitePost(player?: string, options?: any) {
        return ClanApiFp(this.configuration).clanInvitePost(player, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [player] 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanKickplayerPost(player?: string, id?: number, options?: any) {
        return ClanApiFp(this.configuration).clanKickplayerPost(player, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanLeavePost(id?: number, options?: any) {
        return ClanApiFp(this.configuration).clanLeavePost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {string} [name] 
     * @param {string} [color] 
     * @param {string} [description] 
     * @param {string} [bio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanPut(id?: number, name?: string, color?: string, description?: string, bio?: string, options?: any) {
        return ClanApiFp(this.configuration).clanPut(id, name, color, description, bio, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {boolean} [ban] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanRejectPost(id?: number, ban?: boolean, options?: any) {
        return ClanApiFp(this.configuration).clanRejectPost(id, ban, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanReserveDelete(tag?: string, options?: any) {
        return ClanApiFp(this.configuration).clanReserveDelete(tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanReservePost(tag?: string, options?: any) {
        return ClanApiFp(this.configuration).clanReservePost(tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tag 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [sort] 
     * @param {Order} [order] 
     * @param {string} [search] 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanTagGet(tag: string, page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, options?: any) {
        return ClanApiFp(this.configuration).clanTagGet(tag, page, count, sort, order, search, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clanUnbanPost(id?: number, options?: any) {
        return ClanApiFp(this.configuration).clanUnbanPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [sort] 
     * @param {Order} [order] 
     * @param {string} [search] 
     * @param {string} [type] 
     * @param {string} [sortBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClanApi
     */
    public clansGet(page?: number, count?: number, sort?: string, order?: Order, search?: string, type?: string, sortBy?: string, options?: any) {
        return ClanApiFp(this.configuration).clansGet(page, count, sort, order, search, type, sortBy, options)(this.fetch, this.basePath);
    }

}
/**
 * CurrentUserApi - fetch parameter creator
 * @export
 */
export const CurrentUserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [reason] 
         * @param {number} [duration] 
         * @param {boolean} [bot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBanPost(id?: string, reason?: string, duration?: number, bot?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user/ban`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (bot !== undefined) {
                localVarQueryParameter['bot'] = bot;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [newLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeLoginPatch(newLogin?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/changeLogin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (newLogin !== undefined) {
                localVarFormParams.set('newLogin', newLogin as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [oldPassword] 
         * @param {string} [newPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePasswordPatch(login?: string, oldPassword?: string, newPassword?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/changePassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (login !== undefined) {
                localVarFormParams.set('login', login as any);
            }

            if (oldPassword !== undefined) {
                localVarFormParams.set('oldPassword', oldPassword as any);
            }

            if (newPassword !== undefined) {
                localVarFormParams.set('newPassword', newPassword as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCoverDelete(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/cover`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCoverPatch(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/cover`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreFalsepositivePost(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user/failedscore/falsepositive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreRemovePost(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user/failedscore/remove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {boolean} [allow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreRetryPost(id?: number, allow?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/user/failedscore/retry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (allow !== undefined) {
                localVarQueryParameter['allow'] = allow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoresGet(page?: number, count?: number, id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/failedscores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendDelete(playerId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/friend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendPost(playerId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/friend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHideopscoresPost(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/hideopscores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/id`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMigratePost(login?: string, password?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/migrate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (login !== undefined) {
                localVarFormParams.set('login', login as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMigrateoculuspcGet(returnUrl?: string, token?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/migrateoculuspc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['ReturnUrl'] = returnUrl;
            }

            if (token !== undefined) {
                localVarQueryParameter['Token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userModinterfaceGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/modinterface`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [country] 
         * @param {string} [profileAppearance] 
         * @param {string} [message] 
         * @param {number} [hue] 
         * @param {number} [saturation] 
         * @param {string} [effectName] 
         * @param {string} [leftSaberColor] 
         * @param {string} [rightSaberColor] 
         * @param {string} [starredFriends] 
         * @param {boolean} [showBots] 
         * @param {boolean} [showAllRatings] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatch(name?: string, country?: string, profileAppearance?: string, message?: string, hue?: number, saturation?: number, effectName?: string, leftSaberColor?: string, rightSaberColor?: string, starredFriends?: string, showBots?: boolean, showAllRatings?: boolean, id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (profileAppearance !== undefined) {
                localVarQueryParameter['profileAppearance'] = profileAppearance;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (hue !== undefined) {
                localVarQueryParameter['hue'] = hue;
            }

            if (saturation !== undefined) {
                localVarQueryParameter['saturation'] = saturation;
            }

            if (effectName !== undefined) {
                localVarQueryParameter['effectName'] = effectName;
            }

            if (leftSaberColor !== undefined) {
                localVarQueryParameter['leftSaberColor'] = leftSaberColor;
            }

            if (rightSaberColor !== undefined) {
                localVarQueryParameter['rightSaberColor'] = rightSaberColor;
            }

            if (starredFriends !== undefined) {
                localVarQueryParameter['starredFriends'] = starredFriends;
            }

            if (showBots !== undefined) {
                localVarQueryParameter['showBots'] = showBots;
            }

            if (showAllRatings !== undefined) {
                localVarQueryParameter['showAllRatings'] = showAllRatings;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [newPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPasswordPatch(login?: string, newPassword?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/resetPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (login !== undefined) {
                localVarFormParams.set('login', login as any);
            }

            if (newPassword !== undefined) {
                localVarFormParams.set('newPassword', newPassword as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnbanPost(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/unban`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrentUserApi - functional programming interface
 * @export
 */
export const CurrentUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [reason] 
         * @param {number} [duration] 
         * @param {boolean} [bot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBanPost(id?: string, reason?: string, duration?: number, bot?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userBanPost(id, reason, duration, bot, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [newLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeLoginPatch(newLogin?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userChangeLoginPatch(newLogin, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [oldPassword] 
         * @param {string} [newPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePasswordPatch(login?: string, oldPassword?: string, newPassword?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userChangePasswordPatch(login, oldPassword, newPassword, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCoverDelete(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userCoverDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCoverPatch(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userCoverPatch(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreFalsepositivePost(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userFailedscoreFalsepositivePost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreRemovePost(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userFailedscoreRemovePost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {boolean} [allow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreRetryPost(id?: number, allow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponse> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userFailedscoreRetryPost(id, allow, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoresGet(page?: number, count?: number, id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FailedScoreResponseWithMetadata> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userFailedscoresGet(page, count, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendDelete(playerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userFriendDelete(playerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendPost(playerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userFriendPost(playerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserReturn> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHideopscoresPost(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userHideopscoresPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userIdGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMigratePost(login?: string, password?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userMigratePost(login, password, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMigrateoculuspcGet(returnUrl?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userMigrateoculuspcGet(returnUrl, token, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userModinterfaceGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseWithFriends> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userModinterfaceGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [country] 
         * @param {string} [profileAppearance] 
         * @param {string} [message] 
         * @param {number} [hue] 
         * @param {number} [saturation] 
         * @param {string} [effectName] 
         * @param {string} [leftSaberColor] 
         * @param {string} [rightSaberColor] 
         * @param {string} [starredFriends] 
         * @param {boolean} [showBots] 
         * @param {boolean} [showAllRatings] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatch(name?: string, country?: string, profileAppearance?: string, message?: string, hue?: number, saturation?: number, effectName?: string, leftSaberColor?: string, rightSaberColor?: string, starredFriends?: string, showBots?: boolean, showAllRatings?: boolean, id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userPatch(name, country, profileAppearance, message, hue, saturation, effectName, leftSaberColor, rightSaberColor, starredFriends, showBots, showAllRatings, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [newPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPasswordPatch(login?: string, newPassword?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userResetPasswordPatch(login, newPassword, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnbanPost(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).userUnbanPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CurrentUserApi - factory interface
 * @export
 */
export const CurrentUserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [reason] 
         * @param {number} [duration] 
         * @param {boolean} [bot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBanPost(id?: string, reason?: string, duration?: number, bot?: boolean, options?: any) {
            return CurrentUserApiFp(configuration).userBanPost(id, reason, duration, bot, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [newLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangeLoginPatch(newLogin?: string, options?: any) {
            return CurrentUserApiFp(configuration).userChangeLoginPatch(newLogin, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [oldPassword] 
         * @param {string} [newPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePasswordPatch(login?: string, oldPassword?: string, newPassword?: string, options?: any) {
            return CurrentUserApiFp(configuration).userChangePasswordPatch(login, oldPassword, newPassword, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCoverDelete(id?: string, options?: any) {
            return CurrentUserApiFp(configuration).userCoverDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCoverPatch(id?: string, options?: any) {
            return CurrentUserApiFp(configuration).userCoverPatch(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreFalsepositivePost(id?: number, options?: any) {
            return CurrentUserApiFp(configuration).userFailedscoreFalsepositivePost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreRemovePost(id?: number, options?: any) {
            return CurrentUserApiFp(configuration).userFailedscoreRemovePost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {boolean} [allow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoreRetryPost(id?: number, allow?: boolean, options?: any) {
            return CurrentUserApiFp(configuration).userFailedscoreRetryPost(id, allow, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFailedscoresGet(page?: number, count?: number, id?: string, options?: any) {
            return CurrentUserApiFp(configuration).userFailedscoresGet(page, count, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendDelete(playerId?: string, options?: any) {
            return CurrentUserApiFp(configuration).userFriendDelete(playerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [playerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendPost(playerId?: string, options?: any) {
            return CurrentUserApiFp(configuration).userFriendPost(playerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: any) {
            return CurrentUserApiFp(configuration).userGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHideopscoresPost(id?: string, options?: any) {
            return CurrentUserApiFp(configuration).userHideopscoresPost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(options?: any) {
            return CurrentUserApiFp(configuration).userIdGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMigratePost(login?: string, password?: string, options?: any) {
            return CurrentUserApiFp(configuration).userMigratePost(login, password, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMigrateoculuspcGet(returnUrl?: string, token?: string, options?: any) {
            return CurrentUserApiFp(configuration).userMigrateoculuspcGet(returnUrl, token, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userModinterfaceGet(options?: any) {
            return CurrentUserApiFp(configuration).userModinterfaceGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [country] 
         * @param {string} [profileAppearance] 
         * @param {string} [message] 
         * @param {number} [hue] 
         * @param {number} [saturation] 
         * @param {string} [effectName] 
         * @param {string} [leftSaberColor] 
         * @param {string} [rightSaberColor] 
         * @param {string} [starredFriends] 
         * @param {boolean} [showBots] 
         * @param {boolean} [showAllRatings] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatch(name?: string, country?: string, profileAppearance?: string, message?: string, hue?: number, saturation?: number, effectName?: string, leftSaberColor?: string, rightSaberColor?: string, starredFriends?: string, showBots?: boolean, showAllRatings?: boolean, id?: string, options?: any) {
            return CurrentUserApiFp(configuration).userPatch(name, country, profileAppearance, message, hue, saturation, effectName, leftSaberColor, rightSaberColor, starredFriends, showBots, showAllRatings, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [login] 
         * @param {string} [newPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userResetPasswordPatch(login?: string, newPassword?: string, options?: any) {
            return CurrentUserApiFp(configuration).userResetPasswordPatch(login, newPassword, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnbanPost(id?: string, options?: any) {
            return CurrentUserApiFp(configuration).userUnbanPost(id, options)(fetch, basePath);
        },
    };
};

/**
 * CurrentUserApi - object-oriented interface
 * @export
 * @class CurrentUserApi
 * @extends {BaseAPI}
 */
export class CurrentUserApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [reason] 
     * @param {number} [duration] 
     * @param {boolean} [bot] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userBanPost(id?: string, reason?: string, duration?: number, bot?: boolean, options?: any) {
        return CurrentUserApiFp(this.configuration).userBanPost(id, reason, duration, bot, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [newLogin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userChangeLoginPatch(newLogin?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userChangeLoginPatch(newLogin, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [login] 
     * @param {string} [oldPassword] 
     * @param {string} [newPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userChangePasswordPatch(login?: string, oldPassword?: string, newPassword?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userChangePasswordPatch(login, oldPassword, newPassword, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userCoverDelete(id?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userCoverDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userCoverPatch(id?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userCoverPatch(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userFailedscoreFalsepositivePost(id?: number, options?: any) {
        return CurrentUserApiFp(this.configuration).userFailedscoreFalsepositivePost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userFailedscoreRemovePost(id?: number, options?: any) {
        return CurrentUserApiFp(this.configuration).userFailedscoreRemovePost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {boolean} [allow] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userFailedscoreRetryPost(id?: number, allow?: boolean, options?: any) {
        return CurrentUserApiFp(this.configuration).userFailedscoreRetryPost(id, allow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userFailedscoresGet(page?: number, count?: number, id?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userFailedscoresGet(page, count, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [playerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userFriendDelete(playerId?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userFriendDelete(playerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [playerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userFriendPost(playerId?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userFriendPost(playerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userGet(options?: any) {
        return CurrentUserApiFp(this.configuration).userGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userHideopscoresPost(id?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userHideopscoresPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userIdGet(options?: any) {
        return CurrentUserApiFp(this.configuration).userIdGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [login] 
     * @param {string} [password] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userMigratePost(login?: string, password?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userMigratePost(login, password, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userMigrateoculuspcGet(returnUrl?: string, token?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userMigrateoculuspcGet(returnUrl, token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userModinterfaceGet(options?: any) {
        return CurrentUserApiFp(this.configuration).userModinterfaceGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {string} [country] 
     * @param {string} [profileAppearance] 
     * @param {string} [message] 
     * @param {number} [hue] 
     * @param {number} [saturation] 
     * @param {string} [effectName] 
     * @param {string} [leftSaberColor] 
     * @param {string} [rightSaberColor] 
     * @param {string} [starredFriends] 
     * @param {boolean} [showBots] 
     * @param {boolean} [showAllRatings] 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userPatch(name?: string, country?: string, profileAppearance?: string, message?: string, hue?: number, saturation?: number, effectName?: string, leftSaberColor?: string, rightSaberColor?: string, starredFriends?: string, showBots?: boolean, showAllRatings?: boolean, id?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userPatch(name, country, profileAppearance, message, hue, saturation, effectName, leftSaberColor, rightSaberColor, starredFriends, showBots, showAllRatings, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [login] 
     * @param {string} [newPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userResetPasswordPatch(login?: string, newPassword?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userResetPasswordPatch(login, newPassword, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userUnbanPost(id?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).userUnbanPost(id, options)(this.fetch, this.basePath);
    }

}
/**
 * FriendsApi - fetch parameter creator
 * @export
 */
export const FriendsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {FriendActivityType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendActivityGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, type?: FriendActivityType, options: any = {}): FetchArgs {
            const localVarPath = `/user/friendActivity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [type] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendScoresGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: string, starsFrom?: number, starsTo?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user/friendScores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendsApi - functional programming interface
 * @export
 */
export const FriendsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {FriendActivityType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendActivityGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, type?: FriendActivityType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FriendActivityResponseWithMetadata> {
            const localVarFetchArgs = FriendsApiFetchParamCreator(configuration).userFriendActivityGet(id, sortBy, order, page, count, search, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [type] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendScoresGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: string, starsFrom?: number, starsTo?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponseWithMyScoreResponseWithMetadata> {
            const localVarFetchArgs = FriendsApiFetchParamCreator(configuration).userFriendScoresGet(id, sortBy, order, page, count, search, diff, type, starsFrom, starsTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FriendsApi - factory interface
 * @export
 */
export const FriendsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {FriendActivityType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendActivityGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, type?: FriendActivityType, options?: any) {
            return FriendsApiFp(configuration).userFriendActivityGet(id, sortBy, order, page, count, search, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [type] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFriendScoresGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: string, starsFrom?: number, starsTo?: number, options?: any) {
            return FriendsApiFp(configuration).userFriendScoresGet(id, sortBy, order, page, count, search, diff, type, starsFrom, starsTo, options)(fetch, basePath);
        },
    };
};

/**
 * FriendsApi - object-oriented interface
 * @export
 * @class FriendsApi
 * @extends {BaseAPI}
 */
export class FriendsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {FriendActivityType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public userFriendActivityGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, type?: FriendActivityType, options?: any) {
        return FriendsApiFp(this.configuration).userFriendActivityGet(id, sortBy, order, page, count, search, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {string} [diff] 
     * @param {string} [type] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public userFriendScoresGet(id?: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: string, starsFrom?: number, starsTo?: number, options?: any) {
        return FriendsApiFp(this.configuration).userFriendScoresGet(id, sortBy, order, page, count, search, diff, type, starsFrom, starsTo, options)(this.fetch, this.basePath);
    }

}
/**
 * LeaderboardApi - fetch parameter creator
 * @export
 */
export const LeaderboardApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [countries] 
         * @param {string} [search] 
         * @param {string} [modifiers] 
         * @param {boolean} [friends] 
         * @param {boolean} [voters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardIdGet(id: string, page?: number, count?: number, sortBy?: string, order?: Order, scoreStatus?: ScoreFilterStatus, countries?: string, search?: string, modifiers?: string, friends?: boolean, voters?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling leaderboardIdGet.');
            }
            const localVarPath = `/leaderboard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (scoreStatus !== undefined) {
                localVarQueryParameter['scoreStatus'] = scoreStatus;
            }

            if (countries !== undefined) {
                localVarQueryParameter['countries'] = countries;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            if (friends !== undefined) {
                localVarQueryParameter['friends'] = friends;
            }

            if (voters !== undefined) {
                localVarQueryParameter['voters'] = voters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRankingIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling leaderboardRankingIdGet.');
            }
            const localVarPath = `/leaderboard/ranking/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardStatisticIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling leaderboardStatisticIdGet.');
            }
            const localVarPath = `/leaderboard/statistic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options: any = {}): FetchArgs {
            const localVarPath = `/leaderboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (mapType !== undefined) {
                localVarQueryParameter['mapType'] = mapType;
            }

            if (allTypes !== undefined) {
                localVarQueryParameter['allTypes'] = allTypes;
            }

            if (mapRequirements !== undefined) {
                localVarQueryParameter['mapRequirements'] = mapRequirements;
            }

            if (allRequirements !== undefined) {
                localVarQueryParameter['allRequirements'] = allRequirements;
            }

            if (mytype !== undefined) {
                localVarQueryParameter['mytype'] = mytype;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (accratingFrom !== undefined) {
                localVarQueryParameter['accrating_from'] = accratingFrom;
            }

            if (accratingTo !== undefined) {
                localVarQueryParameter['accrating_to'] = accratingTo;
            }

            if (passratingFrom !== undefined) {
                localVarQueryParameter['passrating_from'] = passratingFrom;
            }

            if (passratingTo !== undefined) {
                localVarQueryParameter['passrating_to'] = passratingTo;
            }

            if (techratingFrom !== undefined) {
                localVarQueryParameter['techrating_from'] = techratingFrom;
            }

            if (techratingTo !== undefined) {
                localVarQueryParameter['techrating_to'] = techratingTo;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = dateTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsGrouppedGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options: any = {}): FetchArgs {
            const localVarPath = `/leaderboards/groupped`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (mapType !== undefined) {
                localVarQueryParameter['mapType'] = mapType;
            }

            if (allTypes !== undefined) {
                localVarQueryParameter['allTypes'] = allTypes;
            }

            if (mapRequirements !== undefined) {
                localVarQueryParameter['mapRequirements'] = mapRequirements;
            }

            if (allRequirements !== undefined) {
                localVarQueryParameter['allRequirements'] = allRequirements;
            }

            if (mytype !== undefined) {
                localVarQueryParameter['mytype'] = mytype;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (accratingFrom !== undefined) {
                localVarQueryParameter['accrating_from'] = accratingFrom;
            }

            if (accratingTo !== undefined) {
                localVarQueryParameter['accrating_to'] = accratingTo;
            }

            if (passratingFrom !== undefined) {
                localVarQueryParameter['passrating_from'] = passratingFrom;
            }

            if (passratingTo !== undefined) {
                localVarQueryParameter['passrating_to'] = passratingTo;
            }

            if (techratingFrom !== undefined) {
                localVarQueryParameter['techrating_from'] = techratingFrom;
            }

            if (techratingTo !== undefined) {
                localVarQueryParameter['techrating_to'] = techratingTo;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = dateTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsHashHashGet(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling leaderboardsHashHashGet.');
            }
            const localVarPath = `/leaderboards/hash/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsRefreshGet(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/leaderboards/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [countries] 
         * @param {string} [search] 
         * @param {string} [modifiers] 
         * @param {boolean} [friends] 
         * @param {boolean} [voters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardIdGet(id: string, page?: number, count?: number, sortBy?: string, order?: Order, scoreStatus?: ScoreFilterStatus, countries?: string, search?: string, modifiers?: string, friends?: boolean, voters?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardResponse> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardIdGet(id, page, count, sortBy, order, scoreStatus, countries, search, modifiers, friends, voters, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRankingIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardVoting> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardRankingIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardStatisticIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreStatistic> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardStatisticIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardInfoResponseResponseWithMetadata> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardsGet(page, count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsGrouppedGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardInfoResponseResponseWithMetadata> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardsGrouppedGet(page, count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsHashHashGet(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardsResponse> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardsHashHashGet(hash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsRefreshGet(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).leaderboardsRefreshGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [countries] 
         * @param {string} [search] 
         * @param {string} [modifiers] 
         * @param {boolean} [friends] 
         * @param {boolean} [voters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardIdGet(id: string, page?: number, count?: number, sortBy?: string, order?: Order, scoreStatus?: ScoreFilterStatus, countries?: string, search?: string, modifiers?: string, friends?: boolean, voters?: boolean, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardIdGet(id, page, count, sortBy, order, scoreStatus, countries, search, modifiers, friends, voters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRankingIdGet(id: string, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardRankingIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardStatisticIdGet(id: string, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardStatisticIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardsGet(page, count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsGrouppedGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardsGrouppedGet(page, count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsHashHashGet(hash: string, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardsHashHashGet(hash, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardsRefreshGet(id?: string, options?: any) {
            return LeaderboardApiFp(configuration).leaderboardsRefreshGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {ScoreFilterStatus} [scoreStatus] 
     * @param {string} [countries] 
     * @param {string} [search] 
     * @param {string} [modifiers] 
     * @param {boolean} [friends] 
     * @param {boolean} [voters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardIdGet(id: string, page?: number, count?: number, sortBy?: string, order?: Order, scoreStatus?: ScoreFilterStatus, countries?: string, search?: string, modifiers?: string, friends?: boolean, voters?: boolean, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardIdGet(id, page, count, sortBy, order, scoreStatus, countries, search, modifiers, friends, voters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardRankingIdGet(id: string, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardRankingIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardStatisticIdGet(id: string, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardStatisticIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {SortBy} [sortBy] 
     * @param {Order} [order] 
     * @param {string} [search] 
     * @param {Type} [type] 
     * @param {string} [mode] 
     * @param {number} [mapType] 
     * @param {Operation} [allTypes] 
     * @param {Requirements} [mapRequirements] 
     * @param {Operation} [allRequirements] 
     * @param {MyType} [mytype] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [accratingFrom] 
     * @param {number} [accratingTo] 
     * @param {number} [passratingFrom] 
     * @param {number} [passratingTo] 
     * @param {number} [techratingFrom] 
     * @param {number} [techratingTo] 
     * @param {number} [dateFrom] 
     * @param {number} [dateTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardsGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardsGet(page, count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {SortBy} [sortBy] 
     * @param {Order} [order] 
     * @param {string} [search] 
     * @param {Type} [type] 
     * @param {string} [mode] 
     * @param {number} [mapType] 
     * @param {Operation} [allTypes] 
     * @param {Requirements} [mapRequirements] 
     * @param {Operation} [allRequirements] 
     * @param {MyType} [mytype] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [accratingFrom] 
     * @param {number} [accratingTo] 
     * @param {number} [passratingFrom] 
     * @param {number} [passratingTo] 
     * @param {number} [techratingFrom] 
     * @param {number} [techratingTo] 
     * @param {number} [dateFrom] 
     * @param {number} [dateTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardsGrouppedGet(page?: number, count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardsGrouppedGet(page, count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardsHashHashGet(hash: string, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardsHashHashGet(hash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardsRefreshGet(id?: string, options?: any) {
        return LeaderboardApiFp(this.configuration).leaderboardsRefreshGet(id, options)(this.fetch, this.basePath);
    }

}
/**
 * MapEvaluationApi - fetch parameter creator
 * @export
 */
export const MapEvaluationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        criteriaCheckIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling criteriaCheckIdGet.');
            }
            const localVarPath = `/criteria/check/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MapEvaluationApi - functional programming interface
 * @export
 */
export const MapEvaluationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        criteriaCheckIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MapCheckResult> {
            const localVarFetchArgs = MapEvaluationApiFetchParamCreator(configuration).criteriaCheckIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MapEvaluationApi - factory interface
 * @export
 */
export const MapEvaluationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        criteriaCheckIdGet(id: string, options?: any) {
            return MapEvaluationApiFp(configuration).criteriaCheckIdGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * MapEvaluationApi - object-oriented interface
 * @export
 * @class MapEvaluationApi
 * @extends {BaseAPI}
 */
export class MapEvaluationApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapEvaluationApi
     */
    public criteriaCheckIdGet(id: string, options?: any) {
        return MapEvaluationApiFp(this.configuration).criteriaCheckIdGet(id, options)(this.fetch, this.basePath);
    }

}
/**
 * MiniRankingApi - fetch parameter creator
 * @export
 */
export const MiniRankingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [rank] 
         * @param {string} [country] 
         * @param {number} [countryRank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minirankingsGet(rank?: number, country?: string, countryRank?: number, options: any = {}): FetchArgs {
            const localVarPath = `/minirankings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rank !== undefined) {
                localVarQueryParameter['rank'] = rank;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (countryRank !== undefined) {
                localVarQueryParameter['countryRank'] = countryRank;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiniRankingApi - functional programming interface
 * @export
 */
export const MiniRankingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [rank] 
         * @param {string} [country] 
         * @param {number} [countryRank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minirankingsGet(rank?: number, country?: string, countryRank?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MiniRankingResponse> {
            const localVarFetchArgs = MiniRankingApiFetchParamCreator(configuration).minirankingsGet(rank, country, countryRank, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MiniRankingApi - factory interface
 * @export
 */
export const MiniRankingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [rank] 
         * @param {string} [country] 
         * @param {number} [countryRank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minirankingsGet(rank?: number, country?: string, countryRank?: number, options?: any) {
            return MiniRankingApiFp(configuration).minirankingsGet(rank, country, countryRank, options)(fetch, basePath);
        },
    };
};

/**
 * MiniRankingApi - object-oriented interface
 * @export
 * @class MiniRankingApi
 * @extends {BaseAPI}
 */
export class MiniRankingApi extends BaseAPI {
    /**
     * 
     * @param {number} [rank] 
     * @param {string} [country] 
     * @param {number} [countryRank] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiniRankingApi
     */
    public minirankingsGet(rank?: number, country?: string, countryRank?: number, options?: any) {
        return MiniRankingApiFp(this.configuration).minirankingsGet(rank, country, countryRank, options)(this.fetch, this.basePath);
    }

}
/**
 * ModApi - fetch parameter creator
 * @export
 */
export const ModApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modLastVersionsGet(options: any = {}): FetchArgs {
            const localVarPath = `/mod/lastVersions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servernameGet(options: any = {}): FetchArgs {
            const localVarPath = `/servername`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModApi - functional programming interface
 * @export
 */
export const ModApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modLastVersionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModApiFetchParamCreator(configuration).modLastVersionsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servernameGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ModApiFetchParamCreator(configuration).servernameGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModApi - factory interface
 * @export
 */
export const ModApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modLastVersionsGet(options?: any) {
            return ModApiFp(configuration).modLastVersionsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servernameGet(options?: any) {
            return ModApiFp(configuration).servernameGet(options)(fetch, basePath);
        },
    };
};

/**
 * ModApi - object-oriented interface
 * @export
 * @class ModApi
 * @extends {BaseAPI}
 */
export class ModApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public modLastVersionsGet(options?: any) {
        return ModApiFp(this.configuration).modLastVersionsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public servernameGet(options?: any) {
        return ModApiFp(this.configuration).servernameGet(options)(this.fetch, this.basePath);
    }

}
/**
 * ModifiersApi - fetch parameter creator
 * @export
 */
export const ModifiersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifiersGet(options: any = {}): FetchArgs {
            const localVarPath = `/modifiers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModifiersApi - functional programming interface
 * @export
 */
export const ModifiersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifiersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {
            const localVarFetchArgs = ModifiersApiFetchParamCreator(configuration).modifiersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModifiersApi - factory interface
 * @export
 */
export const ModifiersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifiersGet(options?: any) {
            return ModifiersApiFp(configuration).modifiersGet(options)(fetch, basePath);
        },
    };
};

/**
 * ModifiersApi - object-oriented interface
 * @export
 * @class ModifiersApi
 * @extends {BaseAPI}
 */
export class ModifiersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModifiersApi
     */
    public modifiersGet(options?: any) {
        return ModifiersApiFp(this.configuration).modifiersGet(options)(this.fetch, this.basePath);
    }

}
/**
 * PatreonApi - fetch parameter creator
 * @export
 */
export const PatreonApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPatreonGet(options: any = {}): FetchArgs {
            const localVarPath = `/refreshPatreon`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshmypatreonGet(options: any = {}): FetchArgs {
            const localVarPath = `/refreshmypatreon`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkPatreonGet(returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkPatreon`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatreonApi - functional programming interface
 * @export
 */
export const PatreonApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPatreonGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PatreonApiFetchParamCreator(configuration).refreshPatreonGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshmypatreonGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PatreonApiFetchParamCreator(configuration).refreshmypatreonGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkPatreonGet(returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PatreonApiFetchParamCreator(configuration).userLinkPatreonGet(returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PatreonApi - factory interface
 * @export
 */
export const PatreonApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPatreonGet(options?: any) {
            return PatreonApiFp(configuration).refreshPatreonGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshmypatreonGet(options?: any) {
            return PatreonApiFp(configuration).refreshmypatreonGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkPatreonGet(returnUrl?: string, options?: any) {
            return PatreonApiFp(configuration).userLinkPatreonGet(returnUrl, options)(fetch, basePath);
        },
    };
};

/**
 * PatreonApi - object-oriented interface
 * @export
 * @class PatreonApi
 * @extends {BaseAPI}
 */
export class PatreonApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatreonApi
     */
    public refreshPatreonGet(options?: any) {
        return PatreonApiFp(this.configuration).refreshPatreonGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatreonApi
     */
    public refreshmypatreonGet(options?: any) {
        return PatreonApiFp(this.configuration).refreshmypatreonGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatreonApi
     */
    public userLinkPatreonGet(returnUrl?: string, options?: any) {
        return PatreonApiFp(this.configuration).userLinkPatreonGet(returnUrl, options)(this.fetch, this.basePath);
    }

}
/**
 * PlayerApi - fetch parameter creator
 * @export
 */
export const PlayerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attemptsDelete(options: any = {}): FetchArgs {
            const localVarPath = `/attempts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authinfoLoginDelete(login: string, options: any = {}): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling authinfoLoginDelete.');
            }
            const localVarPath = `/authinfo/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authipsDelete(options: any = {}): FetchArgs {
            const localVarPath = `/authips`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [description] 
         * @param {string} [image] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeIdPut(id: number, description?: string, image?: string, link?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling badgeIdPut.');
            }
            const localVarPath = `/badge/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgePut(description?: string, link?: string, options: any = {}): FetchArgs {
            const localVarPath = `/badge`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [sortBy] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {string} [countries] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdPlayersGet(id: number, sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventIdPlayersGet.');
            }
            const localVarPath = `/event/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (countries !== undefined) {
                localVarQueryParameter['countries'] = countries;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oculususerGet(token?: string, options: any = {}): FetchArgs {
            const localVarPath = `/oculususer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playerId 
         * @param {number} badgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerBadgePlayerIdBadgeIdPut(playerId: string, badgeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'playerId' is not null or undefined
            if (playerId === null || playerId === undefined) {
                throw new RequiredError('playerId','Required parameter playerId was null or undefined when calling playerBadgePlayerIdBadgeIdPut.');
            }
            // verify required parameter 'badgeId' is not null or undefined
            if (badgeId === null || badgeId === undefined) {
                throw new RequiredError('badgeId','Required parameter badgeId was null or undefined when calling playerBadgePlayerIdBadgeIdPut.');
            }
            const localVarPath = `/player/badge/{playerId}/{badgeId}`
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
                .replace(`{${"badgeId"}}`, encodeURIComponent(String(badgeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerBeatsaverIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerBeatsaverIdGet.');
            }
            const localVarPath = `/player/beatsaver/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerDiscordIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerDiscordIdGet.');
            }
            const localVarPath = `/player/discord/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [stats] 
         * @param {boolean} [keepOriginalId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdGet(id: string, stats?: boolean, keepOriginalId?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdGet.');
            }
            const localVarPath = `/player/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stats !== undefined) {
                localVarQueryParameter['stats'] = stats;
            }

            if (keepOriginalId !== undefined) {
                localVarQueryParameter['keepOriginalId'] = keepOriginalId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerlinkIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerlinkIdDelete.');
            }
            const localVarPath = `/playerlink/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerlinkLoginGet(login: string, options: any = {}): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling playerlinkLoginGet.');
            }
            const localVarPath = `/playerlink/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortBy] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {string} [countries] 
         * @param {string} [mapsType] 
         * @param {string} [ppType] 
         * @param {boolean} [friends] 
         * @param {string} [ppRange] 
         * @param {string} [scoreRange] 
         * @param {string} [platform] 
         * @param {string} [role] 
         * @param {string} [hmd] 
         * @param {string} [clans] 
         * @param {number} [activityPeriod] 
         * @param {boolean} [banned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, mapsType?: string, ppType?: string, friends?: boolean, ppRange?: string, scoreRange?: string, platform?: string, role?: string, hmd?: string, clans?: string, activityPeriod?: number, banned?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (countries !== undefined) {
                localVarQueryParameter['countries'] = countries;
            }

            if (mapsType !== undefined) {
                localVarQueryParameter['mapsType'] = mapsType;
            }

            if (ppType !== undefined) {
                localVarQueryParameter['ppType'] = ppType;
            }

            if (friends !== undefined) {
                localVarQueryParameter['friends'] = friends;
            }

            if (ppRange !== undefined) {
                localVarQueryParameter['pp_range'] = ppRange;
            }

            if (scoreRange !== undefined) {
                localVarQueryParameter['score_range'] = scoreRange;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (hmd !== undefined) {
                localVarQueryParameter['hmd'] = hmd;
            }

            if (clans !== undefined) {
                localVarQueryParameter['clans'] = clans;
            }

            if (activityPeriod !== undefined) {
                localVarQueryParameter['activityPeriod'] = activityPeriod;
            }

            if (banned !== undefined) {
                localVarQueryParameter['banned'] = banned;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerApi - functional programming interface
 * @export
 */
export const PlayerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attemptsDelete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).attemptsDelete(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authinfoLoginDelete(login: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).authinfoLoginDelete(login, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authipsDelete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).authipsDelete(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [description] 
         * @param {string} [image] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeIdPut(id: number, description?: string, image?: string, link?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Badge> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).badgeIdPut(id, description, image, link, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgePut(description?: string, link?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Badge> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).badgePut(description, link, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [sortBy] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {string} [countries] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdPlayersGet(id: number, sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseWithStatsResponseWithMetadata> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).eventIdPlayersGet(id, sortBy, page, count, search, order, countries, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oculususerGet(token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OculusUser> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).oculususerGet(token, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} playerId 
         * @param {number} badgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerBadgePlayerIdBadgeIdPut(playerId: string, badgeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playerBadgePlayerIdBadgeIdPut(playerId, badgeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerBeatsaverIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseFull> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playerBeatsaverIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerDiscordIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseFull> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playerDiscordIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [stats] 
         * @param {boolean} [keepOriginalId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdGet(id: string, stats?: boolean, keepOriginalId?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseFull> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playerIdGet(id, stats, keepOriginalId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerlinkIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playerlinkIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerlinkLoginGet(login: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountLink> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playerlinkLoginGet(login, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [sortBy] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {string} [countries] 
         * @param {string} [mapsType] 
         * @param {string} [ppType] 
         * @param {boolean} [friends] 
         * @param {string} [ppRange] 
         * @param {string} [scoreRange] 
         * @param {string} [platform] 
         * @param {string} [role] 
         * @param {string} [hmd] 
         * @param {string} [clans] 
         * @param {number} [activityPeriod] 
         * @param {boolean} [banned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, mapsType?: string, ppType?: string, friends?: boolean, ppRange?: string, scoreRange?: string, platform?: string, role?: string, hmd?: string, clans?: string, activityPeriod?: number, banned?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerResponseWithStatsResponseWithMetadata> {
            const localVarFetchArgs = PlayerApiFetchParamCreator(configuration).playersGet(sortBy, page, count, search, order, countries, mapsType, ppType, friends, ppRange, scoreRange, platform, role, hmd, clans, activityPeriod, banned, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayerApi - factory interface
 * @export
 */
export const PlayerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attemptsDelete(options?: any) {
            return PlayerApiFp(configuration).attemptsDelete(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authinfoLoginDelete(login: string, options?: any) {
            return PlayerApiFp(configuration).authinfoLoginDelete(login, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authipsDelete(options?: any) {
            return PlayerApiFp(configuration).authipsDelete(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [description] 
         * @param {string} [image] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeIdPut(id: number, description?: string, image?: string, link?: string, options?: any) {
            return PlayerApiFp(configuration).badgeIdPut(id, description, image, link, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgePut(description?: string, link?: string, options?: any) {
            return PlayerApiFp(configuration).badgePut(description, link, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [sortBy] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {string} [countries] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdPlayersGet(id: number, sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, options?: any) {
            return PlayerApiFp(configuration).eventIdPlayersGet(id, sortBy, page, count, search, order, countries, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oculususerGet(token?: string, options?: any) {
            return PlayerApiFp(configuration).oculususerGet(token, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} playerId 
         * @param {number} badgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerBadgePlayerIdBadgeIdPut(playerId: string, badgeId: number, options?: any) {
            return PlayerApiFp(configuration).playerBadgePlayerIdBadgeIdPut(playerId, badgeId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerBeatsaverIdGet(id: string, options?: any) {
            return PlayerApiFp(configuration).playerBeatsaverIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerDiscordIdGet(id: string, options?: any) {
            return PlayerApiFp(configuration).playerDiscordIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [stats] 
         * @param {boolean} [keepOriginalId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdGet(id: string, stats?: boolean, keepOriginalId?: boolean, options?: any) {
            return PlayerApiFp(configuration).playerIdGet(id, stats, keepOriginalId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerlinkIdDelete(id: string, options?: any) {
            return PlayerApiFp(configuration).playerlinkIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerlinkLoginGet(login: string, options?: any) {
            return PlayerApiFp(configuration).playerlinkLoginGet(login, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [sortBy] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {string} [countries] 
         * @param {string} [mapsType] 
         * @param {string} [ppType] 
         * @param {boolean} [friends] 
         * @param {string} [ppRange] 
         * @param {string} [scoreRange] 
         * @param {string} [platform] 
         * @param {string} [role] 
         * @param {string} [hmd] 
         * @param {string} [clans] 
         * @param {number} [activityPeriod] 
         * @param {boolean} [banned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, mapsType?: string, ppType?: string, friends?: boolean, ppRange?: string, scoreRange?: string, platform?: string, role?: string, hmd?: string, clans?: string, activityPeriod?: number, banned?: boolean, options?: any) {
            return PlayerApiFp(configuration).playersGet(sortBy, page, count, search, order, countries, mapsType, ppType, friends, ppRange, scoreRange, platform, role, hmd, clans, activityPeriod, banned, options)(fetch, basePath);
        },
    };
};

/**
 * PlayerApi - object-oriented interface
 * @export
 * @class PlayerApi
 * @extends {BaseAPI}
 */
export class PlayerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public attemptsDelete(options?: any) {
        return PlayerApiFp(this.configuration).attemptsDelete(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} login 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public authinfoLoginDelete(login: string, options?: any) {
        return PlayerApiFp(this.configuration).authinfoLoginDelete(login, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public authipsDelete(options?: any) {
        return PlayerApiFp(this.configuration).authipsDelete(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {string} [description] 
     * @param {string} [image] 
     * @param {string} [link] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public badgeIdPut(id: number, description?: string, image?: string, link?: string, options?: any) {
        return PlayerApiFp(this.configuration).badgeIdPut(id, description, image, link, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [description] 
     * @param {string} [link] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public badgePut(description?: string, link?: string, options?: any) {
        return PlayerApiFp(this.configuration).badgePut(description, link, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {string} [sortBy] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {Order} [order] 
     * @param {string} [countries] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public eventIdPlayersGet(id: number, sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, options?: any) {
        return PlayerApiFp(this.configuration).eventIdPlayersGet(id, sortBy, page, count, search, order, countries, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public oculususerGet(token?: string, options?: any) {
        return PlayerApiFp(this.configuration).oculususerGet(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} playerId 
     * @param {number} badgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerBadgePlayerIdBadgeIdPut(playerId: string, badgeId: number, options?: any) {
        return PlayerApiFp(this.configuration).playerBadgePlayerIdBadgeIdPut(playerId, badgeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerBeatsaverIdGet(id: string, options?: any) {
        return PlayerApiFp(this.configuration).playerBeatsaverIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerDiscordIdGet(id: string, options?: any) {
        return PlayerApiFp(this.configuration).playerDiscordIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [stats] 
     * @param {boolean} [keepOriginalId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerIdGet(id: string, stats?: boolean, keepOriginalId?: boolean, options?: any) {
        return PlayerApiFp(this.configuration).playerIdGet(id, stats, keepOriginalId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerlinkIdDelete(id: string, options?: any) {
        return PlayerApiFp(this.configuration).playerlinkIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} login 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerlinkLoginGet(login: string, options?: any) {
        return PlayerApiFp(this.configuration).playerlinkLoginGet(login, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [sortBy] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {Order} [order] 
     * @param {string} [countries] 
     * @param {string} [mapsType] 
     * @param {string} [ppType] 
     * @param {boolean} [friends] 
     * @param {string} [ppRange] 
     * @param {string} [scoreRange] 
     * @param {string} [platform] 
     * @param {string} [role] 
     * @param {string} [hmd] 
     * @param {string} [clans] 
     * @param {number} [activityPeriod] 
     * @param {boolean} [banned] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playersGet(sortBy?: string, page?: number, count?: number, search?: string, order?: Order, countries?: string, mapsType?: string, ppType?: string, friends?: boolean, ppRange?: string, scoreRange?: string, platform?: string, role?: string, hmd?: string, clans?: string, activityPeriod?: number, banned?: boolean, options?: any) {
        return PlayerApiFp(this.configuration).playersGet(sortBy, page, count, search, order, countries, mapsType, ppType, friends, ppRange, scoreRange, platform, role, hmd, clans, activityPeriod, banned, options)(this.fetch, this.basePath);
    }

}
/**
 * PlayerRefreshApi - fetch parameter creator
 * @export
 */
export const PlayerRefreshApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {boolean} [refreshRank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdRefreshGet(id: string, refreshRank?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdRefreshGet.');
            }
            const localVarPath = `/player/{id}/refresh`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshRank !== undefined) {
                localVarQueryParameter['refreshRank'] = refreshRank;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersLeaderboardIdRefreshGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersLeaderboardIdRefreshGet.');
            }
            const localVarPath = `/players/leaderboard/{id}/refresh`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersRankrefreshGet(options: any = {}): FetchArgs {
            const localVarPath = `/players/rankrefresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersRefreshGet(options: any = {}): FetchArgs {
            const localVarPath = `/players/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersStatsRefreshGet(options: any = {}): FetchArgs {
            const localVarPath = `/players/stats/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersSteamRefreshGet(options: any = {}): FetchArgs {
            const localVarPath = `/players/steam/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerRefreshApi - functional programming interface
 * @export
 */
export const PlayerRefreshApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {boolean} [refreshRank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdRefreshGet(id: string, refreshRank?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerRefreshApiFetchParamCreator(configuration).playerIdRefreshGet(id, refreshRank, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersLeaderboardIdRefreshGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerRefreshApiFetchParamCreator(configuration).playersLeaderboardIdRefreshGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersRankrefreshGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerRefreshApiFetchParamCreator(configuration).playersRankrefreshGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersRefreshGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerRefreshApiFetchParamCreator(configuration).playersRefreshGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersStatsRefreshGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerRefreshApiFetchParamCreator(configuration).playersStatsRefreshGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersSteamRefreshGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerRefreshApiFetchParamCreator(configuration).playersSteamRefreshGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayerRefreshApi - factory interface
 * @export
 */
export const PlayerRefreshApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {boolean} [refreshRank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdRefreshGet(id: string, refreshRank?: boolean, options?: any) {
            return PlayerRefreshApiFp(configuration).playerIdRefreshGet(id, refreshRank, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersLeaderboardIdRefreshGet(id: string, options?: any) {
            return PlayerRefreshApiFp(configuration).playersLeaderboardIdRefreshGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersRankrefreshGet(options?: any) {
            return PlayerRefreshApiFp(configuration).playersRankrefreshGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersRefreshGet(options?: any) {
            return PlayerRefreshApiFp(configuration).playersRefreshGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersStatsRefreshGet(options?: any) {
            return PlayerRefreshApiFp(configuration).playersStatsRefreshGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersSteamRefreshGet(options?: any) {
            return PlayerRefreshApiFp(configuration).playersSteamRefreshGet(options)(fetch, basePath);
        },
    };
};

/**
 * PlayerRefreshApi - object-oriented interface
 * @export
 * @class PlayerRefreshApi
 * @extends {BaseAPI}
 */
export class PlayerRefreshApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {boolean} [refreshRank] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerRefreshApi
     */
    public playerIdRefreshGet(id: string, refreshRank?: boolean, options?: any) {
        return PlayerRefreshApiFp(this.configuration).playerIdRefreshGet(id, refreshRank, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerRefreshApi
     */
    public playersLeaderboardIdRefreshGet(id: string, options?: any) {
        return PlayerRefreshApiFp(this.configuration).playersLeaderboardIdRefreshGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerRefreshApi
     */
    public playersRankrefreshGet(options?: any) {
        return PlayerRefreshApiFp(this.configuration).playersRankrefreshGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerRefreshApi
     */
    public playersRefreshGet(options?: any) {
        return PlayerRefreshApiFp(this.configuration).playersRefreshGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerRefreshApi
     */
    public playersStatsRefreshGet(options?: any) {
        return PlayerRefreshApiFp(this.configuration).playersStatsRefreshGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerRefreshApi
     */
    public playersSteamRefreshGet(options?: any) {
        return PlayerRefreshApiFp(this.configuration).playersSteamRefreshGet(options)(this.fetch, this.basePath);
    }

}
/**
 * PlayerScoresApi - fetch parameter creator
 * @export
 */
export const PlayerScoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAccgraphGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdAccgraphGet.');
            }
            const localVarPath = `/player/{id}/accgraph`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {number} [batch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdHistogramGet(id: string, sortBy?: string, order?: Order, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, batch?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdHistogramGet.');
            }
            const localVarPath = `/player/{id}/histogram`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (requirements !== undefined) {
                localVarQueryParameter['requirements'] = requirements;
            }

            if (scoreStatus !== undefined) {
                localVarQueryParameter['scoreStatus'] = scoreStatus;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (timeFrom !== undefined) {
                localVarQueryParameter['time_from'] = timeFrom;
            }

            if (timeTo !== undefined) {
                localVarQueryParameter['time_to'] = timeTo;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdHistoryGet(id: string, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdHistoryGet.');
            }
            const localVarPath = `/player/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdPinnedScoresGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdPinnedScoresGet.');
            }
            const localVarPath = `/player/{id}/pinnedScores`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} leaderboardID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoreLeaderboardIDDelete(id: string, leaderboardID: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdScoreLeaderboardIDDelete.');
            }
            // verify required parameter 'leaderboardID' is not null or undefined
            if (leaderboardID === null || leaderboardID === undefined) {
                throw new RequiredError('leaderboardID','Required parameter leaderboardID was null or undefined when calling playerIdScoreLeaderboardIDDelete.');
            }
            const localVarPath = `/player/{id}/score/{leaderboardID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"leaderboardID"}}`, encodeURIComponent(String(leaderboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresCompactGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdScoresCompactGet.');
            }
            const localVarPath = `/player/{id}/scores/compact`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (requirements !== undefined) {
                localVarQueryParameter['requirements'] = requirements;
            }

            if (scoreStatus !== undefined) {
                localVarQueryParameter['scoreStatus'] = scoreStatus;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (timeFrom !== undefined) {
                localVarQueryParameter['time_from'] = timeFrom;
            }

            if (timeTo !== undefined) {
                localVarQueryParameter['time_to'] = timeTo;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdScoresGet.');
            }
            const localVarPath = `/player/{id}/scores`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (requirements !== undefined) {
                localVarQueryParameter['requirements'] = requirements;
            }

            if (scoreStatus !== undefined) {
                localVarQueryParameter['scoreStatus'] = scoreStatus;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (timeFrom !== undefined) {
                localVarQueryParameter['time_from'] = timeFrom;
            }

            if (timeTo !== undefined) {
                localVarQueryParameter['time_to'] = timeTo;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} hash 
         * @param {string} difficulty 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScorevalueHashDifficultyModeGet(id: string, hash: string, difficulty: string, mode: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdScorevalueHashDifficultyModeGet.');
            }
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling playerIdScorevalueHashDifficultyModeGet.');
            }
            // verify required parameter 'difficulty' is not null or undefined
            if (difficulty === null || difficulty === undefined) {
                throw new RequiredError('difficulty','Required parameter difficulty was null or undefined when calling playerIdScorevalueHashDifficultyModeGet.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling playerIdScorevalueHashDifficultyModeGet.');
            }
            const localVarPath = `/player/{id}/scorevalue/{hash}/{difficulty}/{mode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"difficulty"}}`, encodeURIComponent(String(difficulty)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerScoresApi - functional programming interface
 * @export
 */
export const PlayerScoresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAccgraphGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GraphResponse>> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdAccgraphGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {number} [batch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdHistogramGet(id: string, sortBy?: string, order?: Order, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, batch?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdHistogramGet(id, sortBy, order, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, batch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdHistoryGet(id: string, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PlayerScoreStatsHistory>> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdHistoryGet(id, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdPinnedScoresGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ScoreResponseWithMyScore>> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdPinnedScoresGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} leaderboardID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoreLeaderboardIDDelete(id: string, leaderboardID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdScoreLeaderboardIDDelete(id, leaderboardID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresCompactGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompactScoreResponseResponseWithMetadata> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdScoresCompactGet(id, sortBy, order, page, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponseWithMyScoreResponseWithMetadata> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdScoresGet(id, sortBy, order, page, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} hash 
         * @param {string} difficulty 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScorevalueHashDifficultyModeGet(id: string, hash: string, difficulty: string, mode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = PlayerScoresApiFetchParamCreator(configuration).playerIdScorevalueHashDifficultyModeGet(id, hash, difficulty, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayerScoresApi - factory interface
 * @export
 */
export const PlayerScoresApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdAccgraphGet(id: string, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdAccgraphGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {number} [batch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdHistogramGet(id: string, sortBy?: string, order?: Order, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, batch?: number, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdHistogramGet(id, sortBy, order, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, batch, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdHistoryGet(id: string, count?: number, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdHistoryGet(id, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdPinnedScoresGet(id: string, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdPinnedScoresGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} leaderboardID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoreLeaderboardIDDelete(id: string, leaderboardID: string, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdScoreLeaderboardIDDelete(id, leaderboardID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresCompactGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdScoresCompactGet(id, sortBy, order, page, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {ScoreFilterStatus} [scoreStatus] 
         * @param {string} [type] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdScoresGet(id, sortBy, order, page, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} hash 
         * @param {string} difficulty 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScorevalueHashDifficultyModeGet(id: string, hash: string, difficulty: string, mode: string, options?: any) {
            return PlayerScoresApiFp(configuration).playerIdScorevalueHashDifficultyModeGet(id, hash, difficulty, mode, options)(fetch, basePath);
        },
    };
};

/**
 * PlayerScoresApi - object-oriented interface
 * @export
 * @class PlayerScoresApi
 * @extends {BaseAPI}
 */
export class PlayerScoresApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdAccgraphGet(id: string, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdAccgraphGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {string} [diff] 
     * @param {string} [mode] 
     * @param {Requirements} [requirements] 
     * @param {ScoreFilterStatus} [scoreStatus] 
     * @param {string} [type] 
     * @param {string} [modifiers] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [timeFrom] 
     * @param {number} [timeTo] 
     * @param {number} [eventId] 
     * @param {number} [batch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdHistogramGet(id: string, sortBy?: string, order?: Order, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, batch?: number, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdHistogramGet(id, sortBy, order, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, batch, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdHistoryGet(id: string, count?: number, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdHistoryGet(id, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdPinnedScoresGet(id: string, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdPinnedScoresGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} leaderboardID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdScoreLeaderboardIDDelete(id: string, leaderboardID: string, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdScoreLeaderboardIDDelete(id, leaderboardID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {string} [diff] 
     * @param {string} [mode] 
     * @param {Requirements} [requirements] 
     * @param {ScoreFilterStatus} [scoreStatus] 
     * @param {string} [type] 
     * @param {string} [modifiers] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [timeFrom] 
     * @param {number} [timeTo] 
     * @param {number} [eventId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdScoresCompactGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdScoresCompactGet(id, sortBy, order, page, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {string} [diff] 
     * @param {string} [mode] 
     * @param {Requirements} [requirements] 
     * @param {ScoreFilterStatus} [scoreStatus] 
     * @param {string} [type] 
     * @param {string} [modifiers] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [timeFrom] 
     * @param {number} [timeTo] 
     * @param {number} [eventId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdScoresGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, mode?: string, requirements?: Requirements, scoreStatus?: ScoreFilterStatus, type?: string, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdScoresGet(id, sortBy, order, page, count, search, diff, mode, requirements, scoreStatus, type, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} hash 
     * @param {string} difficulty 
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerScoresApi
     */
    public playerIdScorevalueHashDifficultyModeGet(id: string, hash: string, difficulty: string, mode: string, options?: any) {
        return PlayerScoresApiFp(this.configuration).playerIdScorevalueHashDifficultyModeGet(id, hash, difficulty, mode, options)(this.fetch, this.basePath);
    }

}
/**
 * PlaylistApi - fetch parameter creator
 * @export
 */
export const PlaylistApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventIdGet.');
            }
            const localVarPath = `/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdRefreshGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventIdRefreshGet.');
            }
            const localVarPath = `/event/{id}/refresh`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [name] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventStartIdPost(id: number, name?: string, endDate?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventStartIdPost.');
            }
            const localVarPath = `/event/start/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sortBy] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(page?: number, count?: number, sortBy?: string, search?: string, order?: Order, options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {boolean} [duplicateDiffs] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGenerateGet(count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, duplicateDiffs?: boolean, title?: string, options: any = {}): FetchArgs {
            const localVarPath = `/playlist/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (mapType !== undefined) {
                localVarQueryParameter['mapType'] = mapType;
            }

            if (allTypes !== undefined) {
                localVarQueryParameter['allTypes'] = allTypes;
            }

            if (mapRequirements !== undefined) {
                localVarQueryParameter['mapRequirements'] = mapRequirements;
            }

            if (allRequirements !== undefined) {
                localVarQueryParameter['allRequirements'] = allRequirements;
            }

            if (mytype !== undefined) {
                localVarQueryParameter['mytype'] = mytype;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (accratingFrom !== undefined) {
                localVarQueryParameter['accrating_from'] = accratingFrom;
            }

            if (accratingTo !== undefined) {
                localVarQueryParameter['accrating_to'] = accratingTo;
            }

            if (passratingFrom !== undefined) {
                localVarQueryParameter['passrating_from'] = passratingFrom;
            }

            if (passratingTo !== undefined) {
                localVarQueryParameter['passrating_to'] = passratingTo;
            }

            if (techratingFrom !== undefined) {
                localVarQueryParameter['techrating_from'] = techratingFrom;
            }

            if (techratingTo !== undefined) {
                localVarQueryParameter['techrating_to'] = techratingTo;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = dateTo;
            }

            if (duplicateDiffs !== undefined) {
                localVarQueryParameter['duplicate_diffs'] = duplicateDiffs;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playlistIdGet.');
            }
            const localVarPath = `/playlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistImageIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playlistImageIdGet.');
            }
            const localVarPath = `/playlist/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshnominatedGet(options: any = {}): FetchArgs {
            const localVarPath = `/playlist/refreshnominated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshqualifiedGet(options: any = {}): FetchArgs {
            const localVarPath = `/playlist/refreshqualified`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshrankedGet(options: any = {}): FetchArgs {
            const localVarPath = `/playlist/refreshranked`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [count] 
         * @param {string} [playerId] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [type] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {boolean} [duplicateDiffs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistScoresGenerateGet(count?: number, playerId?: string, sortBy?: string, order?: Order, search?: string, diff?: string, type?: string, mode?: string, requirements?: Requirements, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, duplicateDiffs?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/playlist/scores/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (requirements !== undefined) {
                localVarQueryParameter['requirements'] = requirements;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (timeFrom !== undefined) {
                localVarQueryParameter['time_from'] = timeFrom;
            }

            if (timeTo !== undefined) {
                localVarQueryParameter['time_to'] = timeTo;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (duplicateDiffs !== undefined) {
                localVarQueryParameter['duplicate_diffs'] = duplicateDiffs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsGet(options: any = {}): FetchArgs {
            const localVarPath = `/playlists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickdoneGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/oneclickdone`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickplaylistGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/oneclickplaylist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickplaylistPost(options: any = {}): FetchArgs {
            const localVarPath = `/user/oneclickplaylist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistDelete(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user/playlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistPost(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user/playlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistsGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/playlists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistApi - functional programming interface
 * @export
 */
export const PlaylistApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventRanking> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).eventIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdRefreshGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).eventIdRefreshGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [name] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventStartIdPost(id: number, name?: string, endDate?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).eventStartIdPost(id, name, endDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sortBy] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(page?: number, count?: number, sortBy?: string, search?: string, order?: Order, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventResponseResponseWithMetadata> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).eventsGet(page, count, sortBy, search, order, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {boolean} [duplicateDiffs] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGenerateGet(count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, duplicateDiffs?: boolean, title?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistGenerateGet(count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, duplicateDiffs, title, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistImageIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistImageIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshnominatedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistRefreshnominatedGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshqualifiedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistRefreshqualifiedGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshrankedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistRefreshrankedGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [count] 
         * @param {string} [playerId] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [type] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {boolean} [duplicateDiffs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistScoresGenerateGet(count?: number, playerId?: string, sortBy?: string, order?: Order, search?: string, diff?: string, type?: string, mode?: string, requirements?: Requirements, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, duplicateDiffs?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistScoresGenerateGet(count, playerId, sortBy, order, search, diff, type, mode, requirements, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, duplicateDiffs, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlist>> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).playlistsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickdoneGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).userOneclickdoneGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickplaylistGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).userOneclickplaylistGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickplaylistPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).userOneclickplaylistPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistDelete(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).userPlaylistDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistPost(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).userPlaylistPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Playlist>> {
            const localVarFetchArgs = PlaylistApiFetchParamCreator(configuration).userPlaylistsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlaylistApi - factory interface
 * @export
 */
export const PlaylistApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdGet(id: number, options?: any) {
            return PlaylistApiFp(configuration).eventIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIdRefreshGet(id: number, options?: any) {
            return PlaylistApiFp(configuration).eventIdRefreshGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [name] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventStartIdPost(id: number, name?: string, endDate?: number, options?: any) {
            return PlaylistApiFp(configuration).eventStartIdPost(id, name, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [sortBy] 
         * @param {string} [search] 
         * @param {Order} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(page?: number, count?: number, sortBy?: string, search?: string, order?: Order, options?: any) {
            return PlaylistApiFp(configuration).eventsGet(page, count, sortBy, search, order, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [count] 
         * @param {SortBy} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {Type} [type] 
         * @param {string} [mode] 
         * @param {number} [mapType] 
         * @param {Operation} [allTypes] 
         * @param {Requirements} [mapRequirements] 
         * @param {Operation} [allRequirements] 
         * @param {MyType} [mytype] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [accratingFrom] 
         * @param {number} [accratingTo] 
         * @param {number} [passratingFrom] 
         * @param {number} [passratingTo] 
         * @param {number} [techratingFrom] 
         * @param {number} [techratingTo] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {boolean} [duplicateDiffs] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGenerateGet(count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, duplicateDiffs?: boolean, title?: string, options?: any) {
            return PlaylistApiFp(configuration).playlistGenerateGet(count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, duplicateDiffs, title, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistIdGet(id: string, options?: any) {
            return PlaylistApiFp(configuration).playlistIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistImageIdGet(id: string, options?: any) {
            return PlaylistApiFp(configuration).playlistImageIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshnominatedGet(options?: any) {
            return PlaylistApiFp(configuration).playlistRefreshnominatedGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshqualifiedGet(options?: any) {
            return PlaylistApiFp(configuration).playlistRefreshqualifiedGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistRefreshrankedGet(options?: any) {
            return PlaylistApiFp(configuration).playlistRefreshrankedGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [count] 
         * @param {string} [playerId] 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {string} [type] 
         * @param {string} [mode] 
         * @param {Requirements} [requirements] 
         * @param {string} [modifiers] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [timeFrom] 
         * @param {number} [timeTo] 
         * @param {number} [eventId] 
         * @param {boolean} [duplicateDiffs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistScoresGenerateGet(count?: number, playerId?: string, sortBy?: string, order?: Order, search?: string, diff?: string, type?: string, mode?: string, requirements?: Requirements, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, duplicateDiffs?: boolean, options?: any) {
            return PlaylistApiFp(configuration).playlistScoresGenerateGet(count, playerId, sortBy, order, search, diff, type, mode, requirements, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, duplicateDiffs, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsGet(options?: any) {
            return PlaylistApiFp(configuration).playlistsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickdoneGet(options?: any) {
            return PlaylistApiFp(configuration).userOneclickdoneGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickplaylistGet(options?: any) {
            return PlaylistApiFp(configuration).userOneclickplaylistGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userOneclickplaylistPost(options?: any) {
            return PlaylistApiFp(configuration).userOneclickplaylistPost(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistDelete(id?: number, options?: any) {
            return PlaylistApiFp(configuration).userPlaylistDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistPost(id?: number, options?: any) {
            return PlaylistApiFp(configuration).userPlaylistPost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPlaylistsGet(options?: any) {
            return PlaylistApiFp(configuration).userPlaylistsGet(options)(fetch, basePath);
        },
    };
};

/**
 * PlaylistApi - object-oriented interface
 * @export
 * @class PlaylistApi
 * @extends {BaseAPI}
 */
export class PlaylistApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public eventIdGet(id: number, options?: any) {
        return PlaylistApiFp(this.configuration).eventIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public eventIdRefreshGet(id: number, options?: any) {
        return PlaylistApiFp(this.configuration).eventIdRefreshGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {string} [name] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public eventStartIdPost(id: number, name?: string, endDate?: number, options?: any) {
        return PlaylistApiFp(this.configuration).eventStartIdPost(id, name, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [sortBy] 
     * @param {string} [search] 
     * @param {Order} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public eventsGet(page?: number, count?: number, sortBy?: string, search?: string, order?: Order, options?: any) {
        return PlaylistApiFp(this.configuration).eventsGet(page, count, sortBy, search, order, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [count] 
     * @param {SortBy} [sortBy] 
     * @param {Order} [order] 
     * @param {string} [search] 
     * @param {Type} [type] 
     * @param {string} [mode] 
     * @param {number} [mapType] 
     * @param {Operation} [allTypes] 
     * @param {Requirements} [mapRequirements] 
     * @param {Operation} [allRequirements] 
     * @param {MyType} [mytype] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [accratingFrom] 
     * @param {number} [accratingTo] 
     * @param {number} [passratingFrom] 
     * @param {number} [passratingTo] 
     * @param {number} [techratingFrom] 
     * @param {number} [techratingTo] 
     * @param {number} [dateFrom] 
     * @param {number} [dateTo] 
     * @param {boolean} [duplicateDiffs] 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistGenerateGet(count?: number, sortBy?: SortBy, order?: Order, search?: string, type?: Type, mode?: string, mapType?: number, allTypes?: Operation, mapRequirements?: Requirements, allRequirements?: Operation, mytype?: MyType, starsFrom?: number, starsTo?: number, accratingFrom?: number, accratingTo?: number, passratingFrom?: number, passratingTo?: number, techratingFrom?: number, techratingTo?: number, dateFrom?: number, dateTo?: number, duplicateDiffs?: boolean, title?: string, options?: any) {
        return PlaylistApiFp(this.configuration).playlistGenerateGet(count, sortBy, order, search, type, mode, mapType, allTypes, mapRequirements, allRequirements, mytype, starsFrom, starsTo, accratingFrom, accratingTo, passratingFrom, passratingTo, techratingFrom, techratingTo, dateFrom, dateTo, duplicateDiffs, title, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistIdGet(id: string, options?: any) {
        return PlaylistApiFp(this.configuration).playlistIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistImageIdGet(id: string, options?: any) {
        return PlaylistApiFp(this.configuration).playlistImageIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistRefreshnominatedGet(options?: any) {
        return PlaylistApiFp(this.configuration).playlistRefreshnominatedGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistRefreshqualifiedGet(options?: any) {
        return PlaylistApiFp(this.configuration).playlistRefreshqualifiedGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistRefreshrankedGet(options?: any) {
        return PlaylistApiFp(this.configuration).playlistRefreshrankedGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [count] 
     * @param {string} [playerId] 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {string} [search] 
     * @param {string} [diff] 
     * @param {string} [type] 
     * @param {string} [mode] 
     * @param {Requirements} [requirements] 
     * @param {string} [modifiers] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [timeFrom] 
     * @param {number} [timeTo] 
     * @param {number} [eventId] 
     * @param {boolean} [duplicateDiffs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistScoresGenerateGet(count?: number, playerId?: string, sortBy?: string, order?: Order, search?: string, diff?: string, type?: string, mode?: string, requirements?: Requirements, modifiers?: string, starsFrom?: number, starsTo?: number, timeFrom?: number, timeTo?: number, eventId?: number, duplicateDiffs?: boolean, options?: any) {
        return PlaylistApiFp(this.configuration).playlistScoresGenerateGet(count, playerId, sortBy, order, search, diff, type, mode, requirements, modifiers, starsFrom, starsTo, timeFrom, timeTo, eventId, duplicateDiffs, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public playlistsGet(options?: any) {
        return PlaylistApiFp(this.configuration).playlistsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public userOneclickdoneGet(options?: any) {
        return PlaylistApiFp(this.configuration).userOneclickdoneGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public userOneclickplaylistGet(options?: any) {
        return PlaylistApiFp(this.configuration).userOneclickplaylistGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public userOneclickplaylistPost(options?: any) {
        return PlaylistApiFp(this.configuration).userOneclickplaylistPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public userPlaylistDelete(id?: number, options?: any) {
        return PlaylistApiFp(this.configuration).userPlaylistDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public userPlaylistPost(id?: number, options?: any) {
        return PlaylistApiFp(this.configuration).userPlaylistPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistApi
     */
    public userPlaylistsGet(options?: any) {
        return PlaylistApiFp(this.configuration).userPlaylistsGet(options)(this.fetch, this.basePath);
    }

}
/**
 * PreviewApi - fetch parameter creator
 * @export
 */
export const PreviewApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [playerID] 
         * @param {string} [id] 
         * @param {string} [difficulty] 
         * @param {string} [mode] 
         * @param {string} [link] 
         * @param {number} [scoreId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewReplayGet(playerID?: string, id?: string, difficulty?: string, mode?: string, link?: string, scoreId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/preview/replay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (playerID !== undefined) {
                localVarQueryParameter['playerID'] = playerID;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            if (scoreId !== undefined) {
                localVarQueryParameter['scoreId'] = scoreId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [players] 
         * @param {string} [hash] 
         * @param {string} [difficulty] 
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewRoyaleGet(players?: string, hash?: string, difficulty?: string, mode?: string, options: any = {}): FetchArgs {
            const localVarPath = `/preview/royale`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (players !== undefined) {
                localVarQueryParameter['players'] = players;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreviewApi - functional programming interface
 * @export
 */
export const PreviewApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [playerID] 
         * @param {string} [id] 
         * @param {string} [difficulty] 
         * @param {string} [mode] 
         * @param {string} [link] 
         * @param {number} [scoreId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewReplayGet(playerID?: string, id?: string, difficulty?: string, mode?: string, link?: string, scoreId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PreviewApiFetchParamCreator(configuration).previewReplayGet(playerID, id, difficulty, mode, link, scoreId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [players] 
         * @param {string} [hash] 
         * @param {string} [difficulty] 
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewRoyaleGet(players?: string, hash?: string, difficulty?: string, mode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PreviewApiFetchParamCreator(configuration).previewRoyaleGet(players, hash, difficulty, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PreviewApi - factory interface
 * @export
 */
export const PreviewApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [playerID] 
         * @param {string} [id] 
         * @param {string} [difficulty] 
         * @param {string} [mode] 
         * @param {string} [link] 
         * @param {number} [scoreId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewReplayGet(playerID?: string, id?: string, difficulty?: string, mode?: string, link?: string, scoreId?: number, options?: any) {
            return PreviewApiFp(configuration).previewReplayGet(playerID, id, difficulty, mode, link, scoreId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [players] 
         * @param {string} [hash] 
         * @param {string} [difficulty] 
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewRoyaleGet(players?: string, hash?: string, difficulty?: string, mode?: string, options?: any) {
            return PreviewApiFp(configuration).previewRoyaleGet(players, hash, difficulty, mode, options)(fetch, basePath);
        },
    };
};

/**
 * PreviewApi - object-oriented interface
 * @export
 * @class PreviewApi
 * @extends {BaseAPI}
 */
export class PreviewApi extends BaseAPI {
    /**
     * 
     * @param {string} [playerID] 
     * @param {string} [id] 
     * @param {string} [difficulty] 
     * @param {string} [mode] 
     * @param {string} [link] 
     * @param {number} [scoreId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreviewApi
     */
    public previewReplayGet(playerID?: string, id?: string, difficulty?: string, mode?: string, link?: string, scoreId?: number, options?: any) {
        return PreviewApiFp(this.configuration).previewReplayGet(playerID, id, difficulty, mode, link, scoreId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [players] 
     * @param {string} [hash] 
     * @param {string} [difficulty] 
     * @param {string} [mode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreviewApi
     */
    public previewRoyaleGet(players?: string, hash?: string, difficulty?: string, mode?: string, options?: any) {
        return PreviewApiFp(this.configuration).previewRoyaleGet(players, hash, difficulty, mode, options)(this.fetch, this.basePath);
    }

}
/**
 * RankApi - fetch parameter creator
 * @export
 */
export const RankApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRTJuniorPlayerIdGet(playerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'playerId' is not null or undefined
            if (playerId === null || playerId === undefined) {
                throw new RequiredError('playerId','Required parameter playerId was null or undefined when calling grantRTJuniorPlayerIdGet.');
            }
            const localVarPath = `/grantRTJunior/{playerId}`
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nominateHashDiffModePost(hash: string, diff: string, mode: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling nominateHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling nominateHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling nominateHashDiffModePost.');
            }
            const localVarPath = `/nominate/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prevQualTimeHashGet(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling prevQualTimeHashGet.');
            }
            const localVarPath = `/prevQualTime/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationCommentIdDelete.');
            }
            const localVarPath = `/qualification/comment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationCommentIdPost.');
            }
            const localVarPath = `/qualification/comment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdPut(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationCommentIdPut.');
            }
            const localVarPath = `/qualification/comment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationCriteriaIdDelete.');
            }
            const localVarPath = `/qualification/criteria/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationCriteriaIdPost.');
            }
            const localVarPath = `/qualification/criteria/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdPut(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationCriteriaIdPut.');
            }
            const localVarPath = `/qualification/criteria/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {DifficultyStatus} [newStatus] 
         * @param {number} [accRating] 
         * @param {number} [passRating] 
         * @param {number} [techRating] 
         * @param {number} [type] 
         * @param {number} [criteriaCheck] 
         * @param {string} [criteriaCommentary] 
         * @param {string} [modifiers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationHashDiffModePost(hash: string, diff: string, mode: string, newStatus?: DifficultyStatus, accRating?: number, passRating?: number, techRating?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling qualificationHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling qualificationHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling qualificationHashDiffModePost.');
            }
            const localVarPath = `/qualification/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newStatus !== undefined) {
                localVarQueryParameter['newStatus'] = newStatus;
            }

            if (accRating !== undefined) {
                localVarQueryParameter['accRating'] = accRating;
            }

            if (passRating !== undefined) {
                localVarQueryParameter['passRating'] = passRating;
            }

            if (techRating !== undefined) {
                localVarQueryParameter['techRating'] = techRating;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (criteriaCheck !== undefined) {
                localVarQueryParameter['criteriaCheck'] = criteriaCheck;
            }

            if (criteriaCommentary !== undefined) {
                localVarQueryParameter['criteriaCommentary'] = criteriaCommentary;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {MapQuality} [vote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationVoteIdPost(id: number, vote?: MapQuality, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling qualificationVoteIdPost.');
            }
            const localVarPath = `/qualification/vote/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vote !== undefined) {
                localVarQueryParameter['vote'] = vote;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [rankability] 
         * @param {number} [accRating] 
         * @param {number} [passRating] 
         * @param {number} [techRating] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, accRating?: number, passRating?: number, techRating?: number, type?: number, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling rankHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling rankHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling rankHashDiffModePost.');
            }
            const localVarPath = `/rank/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rankability !== undefined) {
                localVarQueryParameter['rankability'] = rankability;
            }

            if (accRating !== undefined) {
                localVarQueryParameter['accRating'] = accRating;
            }

            if (passRating !== undefined) {
                localVarQueryParameter['passRating'] = passRating;
            }

            if (techRating !== undefined) {
                localVarQueryParameter['techRating'] = techRating;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: number; }} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankabunchPost(body?: { [key: string]: number; }, options: any = {}): FetchArgs {
            const localVarPath = `/rankabunch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: number; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRTJuniorPlayerIdGet(playerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'playerId' is not null or undefined
            if (playerId === null || playerId === undefined) {
                throw new RequiredError('playerId','Required parameter playerId was null or undefined when calling removeRTJuniorPlayerIdGet.');
            }
            const localVarPath = `/removeRTJunior/{playerId}`
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightApproveHashDiffModePost(hash: string, diff: string, mode: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling reweightApproveHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling reweightApproveHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling reweightApproveHashDiffModePost.');
            }
            const localVarPath = `/reweight/approve/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightCancelHashDiffModePost(hash: string, diff: string, mode: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling reweightCancelHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling reweightCancelHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling reweightCancelHashDiffModePost.');
            }
            const localVarPath = `/reweight/cancel/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {boolean} [keep] 
         * @param {number} [stars] 
         * @param {number} [type] 
         * @param {number} [criteriaCheck] 
         * @param {string} [criteriaCommentary] 
         * @param {string} [modifiers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightHashDiffModePost(hash: string, diff: string, mode: string, keep?: boolean, stars?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling reweightHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling reweightHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling reweightHashDiffModePost.');
            }
            const localVarPath = `/reweight/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keep !== undefined) {
                localVarQueryParameter['keep'] = keep;
            }

            if (stars !== undefined) {
                localVarQueryParameter['stars'] = stars;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (criteriaCheck !== undefined) {
                localVarQueryParameter['criteriaCheck'] = criteriaCheck;
            }

            if (criteriaCommentary !== undefined) {
                localVarQueryParameter['criteriaCommentary'] = criteriaCommentary;
            }

            if (modifiers !== undefined) {
                localVarQueryParameter['modifiers'] = modifiers;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [rankability] 
         * @param {string} [stars] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, stars?: string, type?: number, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling voteHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling voteHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling voteHashDiffModePost.');
            }
            const localVarPath = `/vote/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rankability !== undefined) {
                localVarQueryParameter['rankability'] = rankability;
            }

            if (stars !== undefined) {
                localVarQueryParameter['stars'] = stars;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} [ticket] 
         * @param {number} [rankability] 
         * @param {string} [stars] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteSteamHashDiffModePost(hash: string, diff: string, mode: string, ticket?: string, rankability?: number, stars?: string, type?: number, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling voteSteamHashDiffModePost.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling voteSteamHashDiffModePost.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling voteSteamHashDiffModePost.');
            }
            const localVarPath = `/vote/steam/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            if (rankability !== undefined) {
                localVarQueryParameter['rankability'] = rankability;
            }

            if (stars !== undefined) {
                localVarQueryParameter['stars'] = stars;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [scoreId] 
         * @param {number} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votefeedbackPost(scoreId?: number, value?: number, options: any = {}): FetchArgs {
            const localVarPath = `/votefeedback`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (scoreId !== undefined) {
                localVarQueryParameter['scoreId'] = scoreId;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votestatusHashDiffModeGet(hash: string, diff: string, mode: string, player?: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling votestatusHashDiffModeGet.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling votestatusHashDiffModeGet.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling votestatusHashDiffModeGet.');
            }
            const localVarPath = `/votestatus/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votingSpreadGet(options: any = {}): FetchArgs {
            const localVarPath = `/voting/spread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankApi - functional programming interface
 * @export
 */
export const RankApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRTJuniorPlayerIdGet(playerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).grantRTJuniorPlayerIdGet(playerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nominateHashDiffModePost(hash: string, diff: string, mode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).nominateHashDiffModePost(hash, diff, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prevQualTimeHashGet(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrevQualification> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).prevQualTimeHashGet(hash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationCommentIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QualificationCommentary> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationCommentIdPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdPut(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QualificationCommentary> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationCommentIdPut(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationCriteriaIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CriteriaCommentary> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationCriteriaIdPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdPut(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CriteriaCommentary> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationCriteriaIdPut(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {DifficultyStatus} [newStatus] 
         * @param {number} [accRating] 
         * @param {number} [passRating] 
         * @param {number} [techRating] 
         * @param {number} [type] 
         * @param {number} [criteriaCheck] 
         * @param {string} [criteriaCommentary] 
         * @param {string} [modifiers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationHashDiffModePost(hash: string, diff: string, mode: string, newStatus?: DifficultyStatus, accRating?: number, passRating?: number, techRating?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationHashDiffModePost(hash, diff, mode, newStatus, accRating, passRating, techRating, type, criteriaCheck, criteriaCommentary, modifiers, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {MapQuality} [vote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationVoteIdPost(id: number, vote?: MapQuality, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QualificationVote>> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).qualificationVoteIdPost(id, vote, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [rankability] 
         * @param {number} [accRating] 
         * @param {number} [passRating] 
         * @param {number} [techRating] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, accRating?: number, passRating?: number, techRating?: number, type?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).rankHashDiffModePost(hash, diff, mode, rankability, accRating, passRating, techRating, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {{ [key: string]: number; }} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankabunchPost(body?: { [key: string]: number; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).rankabunchPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRTJuniorPlayerIdGet(playerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).removeRTJuniorPlayerIdGet(playerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightApproveHashDiffModePost(hash: string, diff: string, mode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).reweightApproveHashDiffModePost(hash, diff, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightCancelHashDiffModePost(hash: string, diff: string, mode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).reweightCancelHashDiffModePost(hash, diff, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {boolean} [keep] 
         * @param {number} [stars] 
         * @param {number} [type] 
         * @param {number} [criteriaCheck] 
         * @param {string} [criteriaCommentary] 
         * @param {string} [modifiers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightHashDiffModePost(hash: string, diff: string, mode: string, keep?: boolean, stars?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).reweightHashDiffModePost(hash, diff, mode, keep, stars, type, criteriaCheck, criteriaCommentary, modifiers, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [rankability] 
         * @param {string} [stars] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, stars?: string, type?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VoteStatus> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).voteHashDiffModePost(hash, diff, mode, rankability, stars, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} [ticket] 
         * @param {number} [rankability] 
         * @param {string} [stars] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteSteamHashDiffModePost(hash: string, diff: string, mode: string, ticket?: string, rankability?: number, stars?: string, type?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VoteStatus> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).voteSteamHashDiffModePost(hash, diff, mode, ticket, rankability, stars, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [scoreId] 
         * @param {number} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votefeedbackPost(scoreId?: number, value?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).votefeedbackPost(scoreId, value, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votestatusHashDiffModeGet(hash: string, diff: string, mode: string, player?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VoteStatus> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).votestatusHashDiffModeGet(hash, diff, mode, player, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votingSpreadGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).votingSpreadGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RankApi - factory interface
 * @export
 */
export const RankApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRTJuniorPlayerIdGet(playerId: string, options?: any) {
            return RankApiFp(configuration).grantRTJuniorPlayerIdGet(playerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nominateHashDiffModePost(hash: string, diff: string, mode: string, options?: any) {
            return RankApiFp(configuration).nominateHashDiffModePost(hash, diff, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prevQualTimeHashGet(hash: string, options?: any) {
            return RankApiFp(configuration).prevQualTimeHashGet(hash, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdDelete(id: number, options?: any) {
            return RankApiFp(configuration).qualificationCommentIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdPost(id: number, options?: any) {
            return RankApiFp(configuration).qualificationCommentIdPost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCommentIdPut(id: number, options?: any) {
            return RankApiFp(configuration).qualificationCommentIdPut(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdDelete(id: number, options?: any) {
            return RankApiFp(configuration).qualificationCriteriaIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdPost(id: number, options?: any) {
            return RankApiFp(configuration).qualificationCriteriaIdPost(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationCriteriaIdPut(id: number, options?: any) {
            return RankApiFp(configuration).qualificationCriteriaIdPut(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {DifficultyStatus} [newStatus] 
         * @param {number} [accRating] 
         * @param {number} [passRating] 
         * @param {number} [techRating] 
         * @param {number} [type] 
         * @param {number} [criteriaCheck] 
         * @param {string} [criteriaCommentary] 
         * @param {string} [modifiers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationHashDiffModePost(hash: string, diff: string, mode: string, newStatus?: DifficultyStatus, accRating?: number, passRating?: number, techRating?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options?: any) {
            return RankApiFp(configuration).qualificationHashDiffModePost(hash, diff, mode, newStatus, accRating, passRating, techRating, type, criteriaCheck, criteriaCommentary, modifiers, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {MapQuality} [vote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qualificationVoteIdPost(id: number, vote?: MapQuality, options?: any) {
            return RankApiFp(configuration).qualificationVoteIdPost(id, vote, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [rankability] 
         * @param {number} [accRating] 
         * @param {number} [passRating] 
         * @param {number} [techRating] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, accRating?: number, passRating?: number, techRating?: number, type?: number, options?: any) {
            return RankApiFp(configuration).rankHashDiffModePost(hash, diff, mode, rankability, accRating, passRating, techRating, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: number; }} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankabunchPost(body?: { [key: string]: number; }, options?: any) {
            return RankApiFp(configuration).rankabunchPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRTJuniorPlayerIdGet(playerId: string, options?: any) {
            return RankApiFp(configuration).removeRTJuniorPlayerIdGet(playerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightApproveHashDiffModePost(hash: string, diff: string, mode: string, options?: any) {
            return RankApiFp(configuration).reweightApproveHashDiffModePost(hash, diff, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightCancelHashDiffModePost(hash: string, diff: string, mode: string, options?: any) {
            return RankApiFp(configuration).reweightCancelHashDiffModePost(hash, diff, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {boolean} [keep] 
         * @param {number} [stars] 
         * @param {number} [type] 
         * @param {number} [criteriaCheck] 
         * @param {string} [criteriaCommentary] 
         * @param {string} [modifiers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reweightHashDiffModePost(hash: string, diff: string, mode: string, keep?: boolean, stars?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options?: any) {
            return RankApiFp(configuration).reweightHashDiffModePost(hash, diff, mode, keep, stars, type, criteriaCheck, criteriaCommentary, modifiers, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [rankability] 
         * @param {string} [stars] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, stars?: string, type?: number, options?: any) {
            return RankApiFp(configuration).voteHashDiffModePost(hash, diff, mode, rankability, stars, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} [ticket] 
         * @param {number} [rankability] 
         * @param {string} [stars] 
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteSteamHashDiffModePost(hash: string, diff: string, mode: string, ticket?: string, rankability?: number, stars?: string, type?: number, options?: any) {
            return RankApiFp(configuration).voteSteamHashDiffModePost(hash, diff, mode, ticket, rankability, stars, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [scoreId] 
         * @param {number} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votefeedbackPost(scoreId?: number, value?: number, options?: any) {
            return RankApiFp(configuration).votefeedbackPost(scoreId, value, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votestatusHashDiffModeGet(hash: string, diff: string, mode: string, player?: string, options?: any) {
            return RankApiFp(configuration).votestatusHashDiffModeGet(hash, diff, mode, player, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votingSpreadGet(options?: any) {
            return RankApiFp(configuration).votingSpreadGet(options)(fetch, basePath);
        },
    };
};

/**
 * RankApi - object-oriented interface
 * @export
 * @class RankApi
 * @extends {BaseAPI}
 */
export class RankApi extends BaseAPI {
    /**
     * 
     * @param {string} playerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public grantRTJuniorPlayerIdGet(playerId: string, options?: any) {
        return RankApiFp(this.configuration).grantRTJuniorPlayerIdGet(playerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public nominateHashDiffModePost(hash: string, diff: string, mode: string, options?: any) {
        return RankApiFp(this.configuration).nominateHashDiffModePost(hash, diff, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public prevQualTimeHashGet(hash: string, options?: any) {
        return RankApiFp(this.configuration).prevQualTimeHashGet(hash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationCommentIdDelete(id: number, options?: any) {
        return RankApiFp(this.configuration).qualificationCommentIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationCommentIdPost(id: number, options?: any) {
        return RankApiFp(this.configuration).qualificationCommentIdPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationCommentIdPut(id: number, options?: any) {
        return RankApiFp(this.configuration).qualificationCommentIdPut(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationCriteriaIdDelete(id: number, options?: any) {
        return RankApiFp(this.configuration).qualificationCriteriaIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationCriteriaIdPost(id: number, options?: any) {
        return RankApiFp(this.configuration).qualificationCriteriaIdPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationCriteriaIdPut(id: number, options?: any) {
        return RankApiFp(this.configuration).qualificationCriteriaIdPut(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {DifficultyStatus} [newStatus] 
     * @param {number} [accRating] 
     * @param {number} [passRating] 
     * @param {number} [techRating] 
     * @param {number} [type] 
     * @param {number} [criteriaCheck] 
     * @param {string} [criteriaCommentary] 
     * @param {string} [modifiers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationHashDiffModePost(hash: string, diff: string, mode: string, newStatus?: DifficultyStatus, accRating?: number, passRating?: number, techRating?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options?: any) {
        return RankApiFp(this.configuration).qualificationHashDiffModePost(hash, diff, mode, newStatus, accRating, passRating, techRating, type, criteriaCheck, criteriaCommentary, modifiers, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {MapQuality} [vote] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public qualificationVoteIdPost(id: number, vote?: MapQuality, options?: any) {
        return RankApiFp(this.configuration).qualificationVoteIdPost(id, vote, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {number} [rankability] 
     * @param {number} [accRating] 
     * @param {number} [passRating] 
     * @param {number} [techRating] 
     * @param {number} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public rankHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, accRating?: number, passRating?: number, techRating?: number, type?: number, options?: any) {
        return RankApiFp(this.configuration).rankHashDiffModePost(hash, diff, mode, rankability, accRating, passRating, techRating, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: number; }} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public rankabunchPost(body?: { [key: string]: number; }, options?: any) {
        return RankApiFp(this.configuration).rankabunchPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} playerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public removeRTJuniorPlayerIdGet(playerId: string, options?: any) {
        return RankApiFp(this.configuration).removeRTJuniorPlayerIdGet(playerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public reweightApproveHashDiffModePost(hash: string, diff: string, mode: string, options?: any) {
        return RankApiFp(this.configuration).reweightApproveHashDiffModePost(hash, diff, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public reweightCancelHashDiffModePost(hash: string, diff: string, mode: string, options?: any) {
        return RankApiFp(this.configuration).reweightCancelHashDiffModePost(hash, diff, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {boolean} [keep] 
     * @param {number} [stars] 
     * @param {number} [type] 
     * @param {number} [criteriaCheck] 
     * @param {string} [criteriaCommentary] 
     * @param {string} [modifiers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public reweightHashDiffModePost(hash: string, diff: string, mode: string, keep?: boolean, stars?: number, type?: number, criteriaCheck?: number, criteriaCommentary?: string, modifiers?: string, options?: any) {
        return RankApiFp(this.configuration).reweightHashDiffModePost(hash, diff, mode, keep, stars, type, criteriaCheck, criteriaCommentary, modifiers, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {number} [rankability] 
     * @param {string} [stars] 
     * @param {number} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public voteHashDiffModePost(hash: string, diff: string, mode: string, rankability?: number, stars?: string, type?: number, options?: any) {
        return RankApiFp(this.configuration).voteHashDiffModePost(hash, diff, mode, rankability, stars, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {string} [ticket] 
     * @param {number} [rankability] 
     * @param {string} [stars] 
     * @param {number} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public voteSteamHashDiffModePost(hash: string, diff: string, mode: string, ticket?: string, rankability?: number, stars?: string, type?: number, options?: any) {
        return RankApiFp(this.configuration).voteSteamHashDiffModePost(hash, diff, mode, ticket, rankability, stars, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [scoreId] 
     * @param {number} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public votefeedbackPost(scoreId?: number, value?: number, options?: any) {
        return RankApiFp(this.configuration).votefeedbackPost(scoreId, value, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {string} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public votestatusHashDiffModeGet(hash: string, diff: string, mode: string, player?: string, options?: any) {
        return RankApiFp(this.configuration).votestatusHashDiffModeGet(hash, diff, mode, player, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public votingSpreadGet(options?: any) {
        return RankApiFp(this.configuration).votingSpreadGet(options)(this.fetch, this.basePath);
    }

}
/**
 * ReplayApi - fetch parameter creator
 * @export
 */
export const ReplayApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [ticket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayPost(ticket?: string, options: any = {}): FetchArgs {
            const localVarPath = `/replay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [time] 
         * @param {EndType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayoculusPut(time?: number, type?: EndType, options: any = {}): FetchArgs {
            const localVarPath = `/replayoculus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReplayApi - functional programming interface
 * @export
 */
export const ReplayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [ticket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayPost(ticket?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponse> {
            const localVarFetchArgs = ReplayApiFetchParamCreator(configuration).replayPost(ticket, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [time] 
         * @param {EndType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayoculusPut(time?: number, type?: EndType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponse> {
            const localVarFetchArgs = ReplayApiFetchParamCreator(configuration).replayoculusPut(time, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReplayApi - factory interface
 * @export
 */
export const ReplayApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [ticket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayPost(ticket?: string, options?: any) {
            return ReplayApiFp(configuration).replayPost(ticket, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [time] 
         * @param {EndType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayoculusPut(time?: number, type?: EndType, options?: any) {
            return ReplayApiFp(configuration).replayoculusPut(time, type, options)(fetch, basePath);
        },
    };
};

/**
 * ReplayApi - object-oriented interface
 * @export
 * @class ReplayApi
 * @extends {BaseAPI}
 */
export class ReplayApi extends BaseAPI {
    /**
     * 
     * @param {string} [ticket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReplayApi
     */
    public replayPost(ticket?: string, options?: any) {
        return ReplayApiFp(this.configuration).replayPost(ticket, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [time] 
     * @param {EndType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReplayApi
     */
    public replayoculusPut(time?: number, type?: EndType, options?: any) {
        return ReplayApiFp(this.configuration).replayoculusPut(time, type, options)(this.fetch, this.basePath);
    }

}
/**
 * ScoreApi - fetch parameter creator
 * @export
 */
export const ScoreApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaysGet(count?: number, page?: number, dateFrom?: number, dateTo?: number, options: any = {}): FetchArgs {
            const localVarPath = `/replays`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = dateTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreCalculatestatisticIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scoreCalculatestatisticIdGet.');
            }
            const localVarPath = `/score/calculatestatistic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scoreIdDelete.');
            }
            const localVarPath = `/score/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} [fallbackToRedirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdGet(id: number, fallbackToRedirect?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scoreIdGet.');
            }
            const localVarPath = `/score/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fallbackToRedirect !== undefined) {
                localVarQueryParameter['fallbackToRedirect'] = fallbackToRedirect;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} [pin] 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {number} [priority] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdPinPut(id: number, pin?: boolean, description?: string, link?: string, priority?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scoreIdPinPut.');
            }
            const localVarPath = `/score/{id}/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pin !== undefined) {
                localVarQueryParameter['pin'] = pin;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playerID 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scorePlayerIDHashDiffModeGet(playerID: string, hash: string, diff: string, mode: string, options: any = {}): FetchArgs {
            // verify required parameter 'playerID' is not null or undefined
            if (playerID === null || playerID === undefined) {
                throw new RequiredError('playerID','Required parameter playerID was null or undefined when calling scorePlayerIDHashDiffModeGet.');
            }
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling scorePlayerIDHashDiffModeGet.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling scorePlayerIDHashDiffModeGet.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling scorePlayerIDHashDiffModeGet.');
            }
            const localVarPath = `/score/{playerID}/{hash}/{diff}/{mode}`
                .replace(`{${"playerID"}}`, encodeURIComponent(String(playerID)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreRandomGet(options: any = {}): FetchArgs {
            const localVarPath = `/score/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreStatisticIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scoreStatisticIdGet.');
            }
            const localVarPath = `/score/statistic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scorestatsGet(options: any = {}): FetchArgs {
            const localVarPath = `/scorestats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} context 
         * @param {string} scope 
         * @param {string} method 
         * @param {string} [player] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ScoresHashDiffModeContextScopeMethodGet(hash: string, diff: string, mode: string, context: string, scope: string, method: string, player?: string, page?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling v3ScoresHashDiffModeContextScopeMethodGet.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling v3ScoresHashDiffModeContextScopeMethodGet.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling v3ScoresHashDiffModeContextScopeMethodGet.');
            }
            // verify required parameter 'context' is not null or undefined
            if (context === null || context === undefined) {
                throw new RequiredError('context','Required parameter context was null or undefined when calling v3ScoresHashDiffModeContextScopeMethodGet.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling v3ScoresHashDiffModeContextScopeMethodGet.');
            }
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method','Required parameter method was null or undefined when calling v3ScoresHashDiffModeContextScopeMethodGet.');
            }
            const localVarPath = `/v3/scores/{hash}/{diff}/{mode}/{context}/{scope}/{method}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling v4ScoresHashDiffModeGet.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling v4ScoresHashDiffModeGet.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling v4ScoresHashDiffModeGet.');
            }
            const localVarPath = `/v4/scores/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v5ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling v5ScoresHashDiffModeGet.');
            }
            // verify required parameter 'diff' is not null or undefined
            if (diff === null || diff === undefined) {
                throw new RequiredError('diff','Required parameter diff was null or undefined when calling v5ScoresHashDiffModeGet.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling v5ScoresHashDiffModeGet.');
            }
            const localVarPath = `/v5/scores/{hash}/{diff}/{mode}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)))
                .replace(`{${"diff"}}`, encodeURIComponent(String(diff)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoreApi - functional programming interface
 * @export
 */
export const ScoreApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaysGet(count?: number, page?: number, dateFrom?: number, dateTo?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StringResponseWithMetadata> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).replaysGet(count, page, dateFrom, dateTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreCalculatestatisticIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreStatistic> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scoreCalculatestatisticIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scoreIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} [fallbackToRedirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdGet(id: number, fallbackToRedirect?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponse> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scoreIdGet(id, fallbackToRedirect, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} [pin] 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {number} [priority] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdPinPut(id: number, pin?: boolean, description?: string, link?: string, priority?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreMetadata> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scoreIdPinPut(id, pin, description, link, priority, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} playerID 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scorePlayerIDHashDiffModeGet(playerID: string, hash: string, diff: string, mode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Score> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scorePlayerIDHashDiffModeGet(playerID, hash, diff, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreRandomGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Score> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scoreRandomGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreStatisticIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scoreStatisticIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scorestatsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).scorestatsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} context 
         * @param {string} scope 
         * @param {string} method 
         * @param {string} [player] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ScoresHashDiffModeContextScopeMethodGet(hash: string, diff: string, mode: string, context: string, scope: string, method: string, player?: string, page?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreResponseResponseWithMetadataAndSelection> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).v3ScoresHashDiffModeContextScopeMethodGet(hash, diff, mode, context, scope, method, player, page, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaverScoreResponseResponseWithMetadata> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).v4ScoresHashDiffModeGet(hash, diff, mode, page, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v5ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaverScoreResponseSaverContainerResponseResponseWithMetadataAndContainer> {
            const localVarFetchArgs = ScoreApiFetchParamCreator(configuration).v5ScoresHashDiffModeGet(hash, diff, mode, page, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoreApi - factory interface
 * @export
 */
export const ScoreApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {number} [dateFrom] 
         * @param {number} [dateTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaysGet(count?: number, page?: number, dateFrom?: number, dateTo?: number, options?: any) {
            return ScoreApiFp(configuration).replaysGet(count, page, dateFrom, dateTo, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreCalculatestatisticIdGet(id: string, options?: any) {
            return ScoreApiFp(configuration).scoreCalculatestatisticIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdDelete(id: number, options?: any) {
            return ScoreApiFp(configuration).scoreIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} [fallbackToRedirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdGet(id: number, fallbackToRedirect?: boolean, options?: any) {
            return ScoreApiFp(configuration).scoreIdGet(id, fallbackToRedirect, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} [pin] 
         * @param {string} [description] 
         * @param {string} [link] 
         * @param {number} [priority] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreIdPinPut(id: number, pin?: boolean, description?: string, link?: string, priority?: number, options?: any) {
            return ScoreApiFp(configuration).scoreIdPinPut(id, pin, description, link, priority, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} playerID 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scorePlayerIDHashDiffModeGet(playerID: string, hash: string, diff: string, mode: string, options?: any) {
            return ScoreApiFp(configuration).scorePlayerIDHashDiffModeGet(playerID, hash, diff, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreRandomGet(options?: any) {
            return ScoreApiFp(configuration).scoreRandomGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreStatisticIdGet(id: number, options?: any) {
            return ScoreApiFp(configuration).scoreStatisticIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scorestatsGet(options?: any) {
            return ScoreApiFp(configuration).scorestatsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {string} context 
         * @param {string} scope 
         * @param {string} method 
         * @param {string} [player] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ScoresHashDiffModeContextScopeMethodGet(hash: string, diff: string, mode: string, context: string, scope: string, method: string, player?: string, page?: number, count?: number, options?: any) {
            return ScoreApiFp(configuration).v3ScoresHashDiffModeContextScopeMethodGet(hash, diff, mode, context, scope, method, player, page, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v4ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options?: any) {
            return ScoreApiFp(configuration).v4ScoresHashDiffModeGet(hash, diff, mode, page, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {string} diff 
         * @param {string} mode 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v5ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options?: any) {
            return ScoreApiFp(configuration).v5ScoresHashDiffModeGet(hash, diff, mode, page, count, options)(fetch, basePath);
        },
    };
};

/**
 * ScoreApi - object-oriented interface
 * @export
 * @class ScoreApi
 * @extends {BaseAPI}
 */
export class ScoreApi extends BaseAPI {
    /**
     * 
     * @param {number} [count] 
     * @param {number} [page] 
     * @param {number} [dateFrom] 
     * @param {number} [dateTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public replaysGet(count?: number, page?: number, dateFrom?: number, dateTo?: number, options?: any) {
        return ScoreApiFp(this.configuration).replaysGet(count, page, dateFrom, dateTo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scoreCalculatestatisticIdGet(id: string, options?: any) {
        return ScoreApiFp(this.configuration).scoreCalculatestatisticIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scoreIdDelete(id: number, options?: any) {
        return ScoreApiFp(this.configuration).scoreIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {boolean} [fallbackToRedirect] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scoreIdGet(id: number, fallbackToRedirect?: boolean, options?: any) {
        return ScoreApiFp(this.configuration).scoreIdGet(id, fallbackToRedirect, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {boolean} [pin] 
     * @param {string} [description] 
     * @param {string} [link] 
     * @param {number} [priority] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scoreIdPinPut(id: number, pin?: boolean, description?: string, link?: string, priority?: number, options?: any) {
        return ScoreApiFp(this.configuration).scoreIdPinPut(id, pin, description, link, priority, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} playerID 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scorePlayerIDHashDiffModeGet(playerID: string, hash: string, diff: string, mode: string, options?: any) {
        return ScoreApiFp(this.configuration).scorePlayerIDHashDiffModeGet(playerID, hash, diff, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scoreRandomGet(options?: any) {
        return ScoreApiFp(this.configuration).scoreRandomGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scoreStatisticIdGet(id: number, options?: any) {
        return ScoreApiFp(this.configuration).scoreStatisticIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public scorestatsGet(options?: any) {
        return ScoreApiFp(this.configuration).scorestatsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {string} context 
     * @param {string} scope 
     * @param {string} method 
     * @param {string} [player] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public v3ScoresHashDiffModeContextScopeMethodGet(hash: string, diff: string, mode: string, context: string, scope: string, method: string, player?: string, page?: number, count?: number, options?: any) {
        return ScoreApiFp(this.configuration).v3ScoresHashDiffModeContextScopeMethodGet(hash, diff, mode, context, scope, method, player, page, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public v4ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options?: any) {
        return ScoreApiFp(this.configuration).v4ScoresHashDiffModeGet(hash, diff, mode, page, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {string} diff 
     * @param {string} mode 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public v5ScoresHashDiffModeGet(hash: string, diff: string, mode: string, page?: number, count?: number, options?: any) {
        return ScoreApiFp(this.configuration).v5ScoresHashDiffModeGet(hash, diff, mode, page, count, options)(this.fetch, this.basePath);
    }

}
/**
 * ScoreRefreshApi - fetch parameter creator
 * @export
 */
export const ScoreRefreshApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresBulkrankrefreshGet(options: any = {}): FetchArgs {
            const localVarPath = `/scores/bulkrankrefresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresBulkrefreshGet(leaderboardId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/scores/bulkrefresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (leaderboardId !== undefined) {
                localVarQueryParameter['leaderboardId'] = leaderboardId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresRefreshGet(leaderboardId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/scores/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (leaderboardId !== undefined) {
                localVarQueryParameter['leaderboardId'] = leaderboardId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoreRefreshApi - functional programming interface
 * @export
 */
export const ScoreRefreshApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresBulkrankrefreshGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoreRefreshApiFetchParamCreator(configuration).scoresBulkrankrefreshGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresBulkrefreshGet(leaderboardId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoreRefreshApiFetchParamCreator(configuration).scoresBulkrefreshGet(leaderboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresRefreshGet(leaderboardId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoreRefreshApiFetchParamCreator(configuration).scoresRefreshGet(leaderboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoreRefreshApi - factory interface
 * @export
 */
export const ScoreRefreshApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresBulkrankrefreshGet(options?: any) {
            return ScoreRefreshApiFp(configuration).scoresBulkrankrefreshGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresBulkrefreshGet(leaderboardId?: string, options?: any) {
            return ScoreRefreshApiFp(configuration).scoresBulkrefreshGet(leaderboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [leaderboardId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoresRefreshGet(leaderboardId?: string, options?: any) {
            return ScoreRefreshApiFp(configuration).scoresRefreshGet(leaderboardId, options)(fetch, basePath);
        },
    };
};

/**
 * ScoreRefreshApi - object-oriented interface
 * @export
 * @class ScoreRefreshApi
 * @extends {BaseAPI}
 */
export class ScoreRefreshApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreRefreshApi
     */
    public scoresBulkrankrefreshGet(options?: any) {
        return ScoreRefreshApiFp(this.configuration).scoresBulkrankrefreshGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [leaderboardId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreRefreshApi
     */
    public scoresBulkrefreshGet(leaderboardId?: string, options?: any) {
        return ScoreRefreshApiFp(this.configuration).scoresBulkrefreshGet(leaderboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [leaderboardId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreRefreshApi
     */
    public scoresRefreshGet(leaderboardId?: string, options?: any) {
        return ScoreRefreshApiFp(this.configuration).scoresRefreshGet(leaderboardId, options)(this.fetch, this.basePath);
    }

}
/**
 * SocialsApi - fetch parameter creator
 * @export
 */
export const SocialsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatLeaderGet(returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkBeatLeader`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkDiscordGet(returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkDiscord`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkGoogleGet(returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkGoogle`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkTwitchGet(returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkTwitch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkTwitterGet(returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/linkTwitter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnlinkPost(provider?: string, returnUrl?: string, options: any = {}): FetchArgs {
            const localVarPath = `/user/unlink`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (provider !== undefined) {
                localVarFormParams.set('provider', provider as any);
            }

            if (returnUrl !== undefined) {
                localVarFormParams.set('returnUrl', returnUrl as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SocialsApi - functional programming interface
 * @export
 */
export const SocialsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatLeaderGet(returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SocialsApiFetchParamCreator(configuration).userLinkBeatLeaderGet(returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkDiscordGet(returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SocialsApiFetchParamCreator(configuration).userLinkDiscordGet(returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkGoogleGet(returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SocialsApiFetchParamCreator(configuration).userLinkGoogleGet(returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkTwitchGet(returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SocialsApiFetchParamCreator(configuration).userLinkTwitchGet(returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkTwitterGet(returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SocialsApiFetchParamCreator(configuration).userLinkTwitterGet(returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnlinkPost(provider?: string, returnUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SocialsApiFetchParamCreator(configuration).userUnlinkPost(provider, returnUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SocialsApi - factory interface
 * @export
 */
export const SocialsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkBeatLeaderGet(returnUrl?: string, options?: any) {
            return SocialsApiFp(configuration).userLinkBeatLeaderGet(returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkDiscordGet(returnUrl?: string, options?: any) {
            return SocialsApiFp(configuration).userLinkDiscordGet(returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkGoogleGet(returnUrl?: string, options?: any) {
            return SocialsApiFp(configuration).userLinkGoogleGet(returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkTwitchGet(returnUrl?: string, options?: any) {
            return SocialsApiFp(configuration).userLinkTwitchGet(returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLinkTwitterGet(returnUrl?: string, options?: any) {
            return SocialsApiFp(configuration).userLinkTwitterGet(returnUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnlinkPost(provider?: string, returnUrl?: string, options?: any) {
            return SocialsApiFp(configuration).userUnlinkPost(provider, returnUrl, options)(fetch, basePath);
        },
    };
};

/**
 * SocialsApi - object-oriented interface
 * @export
 * @class SocialsApi
 * @extends {BaseAPI}
 */
export class SocialsApi extends BaseAPI {
    /**
     * 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public userLinkBeatLeaderGet(returnUrl?: string, options?: any) {
        return SocialsApiFp(this.configuration).userLinkBeatLeaderGet(returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public userLinkDiscordGet(returnUrl?: string, options?: any) {
        return SocialsApiFp(this.configuration).userLinkDiscordGet(returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public userLinkGoogleGet(returnUrl?: string, options?: any) {
        return SocialsApiFp(this.configuration).userLinkGoogleGet(returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public userLinkTwitchGet(returnUrl?: string, options?: any) {
        return SocialsApiFp(this.configuration).userLinkTwitchGet(returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public userLinkTwitterGet(returnUrl?: string, options?: any) {
        return SocialsApiFp(this.configuration).userLinkTwitterGet(returnUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [provider] 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialsApi
     */
    public userUnlinkPost(provider?: string, returnUrl?: string, options?: any) {
        return SocialsApiFp(this.configuration).userUnlinkPost(provider, returnUrl, options)(this.fetch, this.basePath);
    }

}
/**
 * SongApi - fetch parameter creator
 * @export
 */
export const SongApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapHashHashGet(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling mapHashHashGet.');
            }
            const localVarPath = `/map/hash/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [baseSongId] 
         * @param {string} [oldSongId] 
         * @param {string} [newSongId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapMigratenominationsGet(baseSongId?: string, oldSongId?: string, newSongId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/map/migratenominations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (baseSongId !== undefined) {
                localVarQueryParameter['baseSongId'] = baseSongId;
            }

            if (oldSongId !== undefined) {
                localVarQueryParameter['oldSongId'] = oldSongId;
            }

            if (newSongId !== undefined) {
                localVarQueryParameter['newSongId'] = newSongId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapModinterfaceHashGet(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling mapModinterfaceHashGet.');
            }
            const localVarPath = `/map/modinterface/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongApi - functional programming interface
 * @export
 */
export const SongApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapHashHashGet(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Song> {
            const localVarFetchArgs = SongApiFetchParamCreator(configuration).mapHashHashGet(hash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [baseSongId] 
         * @param {string} [oldSongId] 
         * @param {string} [newSongId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapMigratenominationsGet(baseSongId?: string, oldSongId?: string, newSongId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SongApiFetchParamCreator(configuration).mapMigratenominationsGet(baseSongId, oldSongId, newSongId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapModinterfaceHashGet(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DiffModResponse>> {
            const localVarFetchArgs = SongApiFetchParamCreator(configuration).mapModinterfaceHashGet(hash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SongApi - factory interface
 * @export
 */
export const SongApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapHashHashGet(hash: string, options?: any) {
            return SongApiFp(configuration).mapHashHashGet(hash, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [baseSongId] 
         * @param {string} [oldSongId] 
         * @param {string} [newSongId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapMigratenominationsGet(baseSongId?: string, oldSongId?: string, newSongId?: string, options?: any) {
            return SongApiFp(configuration).mapMigratenominationsGet(baseSongId, oldSongId, newSongId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapModinterfaceHashGet(hash: string, options?: any) {
            return SongApiFp(configuration).mapModinterfaceHashGet(hash, options)(fetch, basePath);
        },
    };
};

/**
 * SongApi - object-oriented interface
 * @export
 * @class SongApi
 * @extends {BaseAPI}
 */
export class SongApi extends BaseAPI {
    /**
     * 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongApi
     */
    public mapHashHashGet(hash: string, options?: any) {
        return SongApiFp(this.configuration).mapHashHashGet(hash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [baseSongId] 
     * @param {string} [oldSongId] 
     * @param {string} [newSongId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongApi
     */
    public mapMigratenominationsGet(baseSongId?: string, oldSongId?: string, newSongId?: string, options?: any) {
        return SongApiFp(this.configuration).mapMigratenominationsGet(baseSongId, oldSongId, newSongId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongApi
     */
    public mapModinterfaceHashGet(hash: string, options?: any) {
        return SongApiFp(this.configuration).mapModinterfaceHashGet(hash, options)(this.fetch, this.basePath);
    }

}
/**
 * StatsApi - fetch parameter creator
 * @export
 */
export const StatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {EndType} [type] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresstatsGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: EndType, starsFrom?: number, starsTo?: number, eventId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playerIdScoresstatsGet.');
            }
            const localVarPath = `/player/{id}/scoresstats`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (starsFrom !== undefined) {
                localVarQueryParameter['stars_from'] = starsFrom;
            }

            if (starsTo !== undefined) {
                localVarQueryParameter['stars_to'] = starsTo;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} scoreId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchedScoreIdGet(scoreId: number, options: any = {}): FetchArgs {
            // verify required parameter 'scoreId' is not null or undefined
            if (scoreId === null || scoreId === undefined) {
                throw new RequiredError('scoreId','Required parameter scoreId was null or undefined when calling watchedScoreIdGet.');
            }
            const localVarPath = `/watched/{scoreId}`
                .replace(`{${"scoreId"}}`, encodeURIComponent(String(scoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {EndType} [type] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresstatsGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: EndType, starsFrom?: number, starsTo?: number, eventId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerLeaderboardStatsResponseWithMetadata> {
            const localVarFetchArgs = StatsApiFetchParamCreator(configuration).playerIdScoresstatsGet(id, sortBy, order, page, count, search, diff, type, starsFrom, starsTo, eventId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} scoreId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchedScoreIdGet(scoreId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VoteStatus> {
            const localVarFetchArgs = StatsApiFetchParamCreator(configuration).watchedScoreIdGet(scoreId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} [sortBy] 
         * @param {Order} [order] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [search] 
         * @param {string} [diff] 
         * @param {EndType} [type] 
         * @param {number} [starsFrom] 
         * @param {number} [starsTo] 
         * @param {number} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerIdScoresstatsGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: EndType, starsFrom?: number, starsTo?: number, eventId?: number, options?: any) {
            return StatsApiFp(configuration).playerIdScoresstatsGet(id, sortBy, order, page, count, search, diff, type, starsFrom, starsTo, eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} scoreId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchedScoreIdGet(scoreId: number, options?: any) {
            return StatsApiFp(configuration).watchedScoreIdGet(scoreId, options)(fetch, basePath);
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {string} [sortBy] 
     * @param {Order} [order] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [search] 
     * @param {string} [diff] 
     * @param {EndType} [type] 
     * @param {number} [starsFrom] 
     * @param {number} [starsTo] 
     * @param {number} [eventId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public playerIdScoresstatsGet(id: string, sortBy?: string, order?: Order, page?: number, count?: number, search?: string, diff?: string, type?: EndType, starsFrom?: number, starsTo?: number, eventId?: number, options?: any) {
        return StatsApiFp(this.configuration).playerIdScoresstatsGet(id, sortBy, order, page, count, search, diff, type, starsFrom, starsTo, eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} scoreId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public watchedScoreIdGet(scoreId: number, options?: any) {
        return StatsApiFp(this.configuration).watchedScoreIdGet(scoreId, options)(this.fetch, this.basePath);
    }

}
/**
 * UnicodeApi - fetch parameter creator
 * @export
 */
export const UnicodeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unicodeNameGet(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling unicodeNameGet.');
            }
            const localVarPath = `/unicode/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnicodeApi - functional programming interface
 * @export
 */
export const UnicodeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unicodeNameGet(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UnicodeApiFetchParamCreator(configuration).unicodeNameGet(name, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UnicodeApi - factory interface
 * @export
 */
export const UnicodeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unicodeNameGet(name: string, options?: any) {
            return UnicodeApiFp(configuration).unicodeNameGet(name, options)(fetch, basePath);
        },
    };
};

/**
 * UnicodeApi - object-oriented interface
 * @export
 * @class UnicodeApi
 * @extends {BaseAPI}
 */
export class UnicodeApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnicodeApi
     */
    public unicodeNameGet(name: string, options?: any) {
        return UnicodeApiFp(this.configuration).unicodeNameGet(name, options)(this.fetch, this.basePath);
    }

}
